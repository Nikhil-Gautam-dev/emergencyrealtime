<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flutter WebSocket Integration Guide - HPlus Medical System</title>
    <style>
        /* CSS for interactive PDF generation */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: #1a1a1a;
            background: #ffffff;
            font-size: 14px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* Cover Page */
        .cover-page {
            page-break-after: always;
            text-align: center;
            padding: 100px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .cover-title {
            font-size: 48px;
            font-weight: 700;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .cover-subtitle {
            font-size: 24px;
            font-weight: 400;
            margin-bottom: 40px;
            opacity: 0.9;
        }
        
        .cover-version {
            font-size: 16px;
            opacity: 0.8;
            margin-top: 60px;
        }
        
        /* Table of Contents */
        .toc {
            page-break-after: always;
            padding: 40px 0;
        }
        
        .toc h1 {
            font-size: 32px;
            color: #2d3748;
            border-bottom: 3px solid #667eea;
            padding-bottom: 15px;
            margin-bottom: 30px;
        }
        
        .toc-list {
            list-style: none;
        }
        
        .toc-item {
            margin-bottom: 12px;
            padding: 8px 0;
            border-bottom: 1px dotted #e2e8f0;
        }
        
        .toc-item a {
            text-decoration: none;
            color: #4a5568;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .toc-item a:hover {
            color: #667eea;
        }
        
        .toc-number {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            min-width: 24px;
            text-align: center;
        }
        
        /* Headers */
        h1 {
            font-size: 28px;
            color: #2d3748;
            margin: 30px 0 20px 0;
            border-left: 4px solid #667eea;
            padding-left: 20px;
            page-break-after: avoid;
        }
        
        h2 {
            font-size: 22px;
            color: #4a5568;
            margin: 25px 0 15px 0;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 8px;
            page-break-after: avoid;
        }
        
        h3 {
            font-size: 18px;
            color: #718096;
            margin: 20px 0 12px 0;
            page-break-after: avoid;
        }
        
        h4 {
            font-size: 16px;
            color: #a0aec0;
            margin: 15px 0 10px 0;
            page-break-after: avoid;
        }
        
        /* Content sections */
        .section {
            margin-bottom: 40px;
            page-break-inside: avoid;
        }
        
        .subsection {
            margin-bottom: 25px;
        }
        
        /* Code blocks */
        pre {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Fira Code', 'Monaco', 'Cascadia Code', monospace;
            font-size: 13px;
            line-height: 1.5;
            page-break-inside: avoid;
        }
        
        code {
            background: #edf2f7;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Fira Code', 'Monaco', 'Cascadia Code', monospace;
            font-size: 13px;
            color: #d53f8c;
        }
        
        /* Info boxes */
        .info-box {
            border-left: 4px solid #4299e1;
            background: #ebf8ff;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 6px 6px 0;
            page-break-inside: avoid;
        }
        
        .warning-box {
            border-left: 4px solid #f56565;
            background: #fed7d7;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 6px 6px 0;
            page-break-inside: avoid;
        }
        
        .success-box {
            border-left: 4px solid #48bb78;
            background: #c6f6d5;
            padding: 15px 20px;
            margin: 20px 0;
            border-radius: 0 6px 6px 0;
            page-break-inside: avoid;
        }
        
        /* Lists */
        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 13px;
            page-break-inside: avoid;
        }
        
        th, td {
            border: 1px solid #e2e8f0;
            padding: 12px 15px;
            text-align: left;
        }
        
        th {
            background: #f7fafc;
            font-weight: 600;
            color: #2d3748;
        }
        
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        
        /* Feature highlights */
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .feature-card {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            page-break-inside: avoid;
        }
        
        .feature-icon {
            font-size: 24px;
            margin-bottom: 10px;
        }
        
        .feature-title {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 8px;
        }
        
        /* Step-by-step guides */
        .step {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            position: relative;
            page-break-inside: avoid;
        }
        
        .step-number {
            position: absolute;
            top: -10px;
            left: 20px;
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
        }
        
        .step-title {
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 10px;
            margin-top: 10px;
        }
        
        /* Page breaks */
        .page-break {
            page-break-before: always;
        }
        
        /* Print styles */
        @media print {
            body {
                font-size: 12px;
            }
            
            .container {
                max-width: none;
                padding: 0;
            }
            
            .cover-page {
                min-height: 100vh;
            }
            
            a {
                color: inherit;
                text-decoration: none;
            }
            
            pre {
                page-break-inside: avoid;
                white-space: pre-wrap;
            }
        }
        
        /* Navigation for interactive use */
        .nav-buttons {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        
        .nav-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
        }
        
        .nav-btn:hover {
            background: #5a67d8;
        }
        
        @media print {
            .nav-buttons {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Cover Page -->
    <div class="cover-page">
        <div class="container">
            <h1 class="cover-title">Flutter WebSocket Integration Guide</h1>
            <p class="cover-subtitle">Complete Implementation Guide for HPlus Medical System</p>
            <div style="margin: 40px 0;">
                <div style="font-size: 18px; margin-bottom: 10px;">üì± Real-time Chat System</div>
                <div style="font-size: 18px; margin-bottom: 10px;">üö® Emergency Dispatch & Tracking</div>
                <div style="font-size: 18px; margin-bottom: 10px;">üìç Location Sharing & GPS Integration</div>
                <div style="font-size: 18px; margin-bottom: 10px;">üè• Multi-Hospital Role-Based Access</div>
            </div>
            <p class="cover-version">Version 2.0 ‚Ä¢ December 2024<br/>Interactive PDF Guide</p>
        </div>
    </div>

    <!-- Table of Contents -->
    <div class="toc page-break">
        <div class="container">
            <h1>üìë Table of Contents</h1>
            <ol class="toc-list">
                <li class="toc-item">
                    <a href="#overview">
                        <span><span class="toc-number">1</span> Overview & System Architecture</span>
                        <span>Page 3</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#prerequisites">
                        <span><span class="toc-number">2</span> Prerequisites & Setup</span>
                        <span>Page 5</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#connection">
                        <span><span class="toc-number">3</span> WebSocket Connection Setup</span>
                        <span>Page 7</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#authentication">
                        <span><span class="toc-number">4</span> Authentication & User Roles</span>
                        <span>Page 12</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#chat-system">
                        <span><span class="toc-number">5</span> Chat System Implementation</span>
                        <span>Page 15</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#emergency-system">
                        <span><span class="toc-number">6</span> Emergency System Implementation</span>
                        <span>Page 25</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#location-sharing">
                        <span><span class="toc-number">7</span> Real-time Location Sharing</span>
                        <span>Page 35</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#message-types">
                        <span><span class="toc-number">8</span> Message Types & Data Structures</span>
                        <span>Page 40</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#flutter-examples">
                        <span><span class="toc-number">9</span> Complete Flutter Implementation Examples</span>
                        <span>Page 45</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#error-handling">
                        <span><span class="toc-number">10</span> Error Handling & Best Practices</span>
                        <span>Page 60</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#testing">
                        <span><span class="toc-number">11</span> Testing & Debugging</span>
                        <span>Page 65</span>
                    </a>
                </li>
                <li class="toc-item">
                    <a href="#appendix">
                        <span><span class="toc-number">12</span> Appendix & Quick Reference</span>
                        <span>Page 70</span>
                    </a>
                </li>
            </ol>
        </div>
    </div>

    <div class="container">
        <!-- Section 1: Overview -->
        <div id="overview" class="section page-break">
            <h1>1. üèóÔ∏è Overview & System Architecture</h1>
            
            <div class="info-box">
                <strong>üí° What you'll learn:</strong> Understanding the HPlus WebSocket system architecture, key features, and how Flutter integrates with the backend for real-time medical communication.
            </div>

            <h2>System Architecture</h2>
            <p>The HPlus backend provides a comprehensive WebSocket system designed specifically for medical facilities, enabling real-time communication between hospitals, paramedics, and patients. The system is built with role-based isolation and multi-hospital support.</p>

            <div class="feature-grid">
                <div class="feature-card">
                    <div class="feature-icon">üè•</div>
                    <div class="feature-title">Multi-Hospital Support</div>
                    <p>Each hospital operates independently with isolated communication channels while maintaining system-wide emergency coordination.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üë•</div>
                    <div class="feature-title">Role-Based Access Control</div>
                    <p>Secure isolation between doctors, nurses, paramedics, patients, and administrative staff with granular permissions.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üí¨</div>
                    <div class="feature-title">Real-time Messaging</div>
                    <p>Instant chat with delivery status, typing indicators, message reactions, and file attachments.</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">üö®</div>
                    <div class="feature-title">Emergency Dispatch</div>
                    <p>Automated emergency request routing with location tracking and real-time ambulance monitoring.</p>
                </div>
            </div>

            <h2>Key Features</h2>
            <div class="success-box">
                <strong>‚úÖ Core Capabilities:</strong>
                <ul>
                    <li><strong>Secure role-based access control</strong> - Each user type has specific permissions</li>
                    <li><strong>Multi-hospital support</strong> - Independent hospital operations with shared emergency services</li>
                    <li><strong>Real-time messaging with delivery status</strong> - Know when messages are sent, delivered, and read</li>
                    <li><strong>Emergency request and response system</strong> - Automated dispatch and tracking</li>
                    <li><strong>GPS location tracking</strong> - Real-time location sharing for emergency services</li>
                    <li><strong>Call management</strong> - Video/voice call initiation, acceptance, and management</li>
                    <li><strong>Automatic reconnection handling</strong> - Robust connection management with offline support</li>
                </ul>
            </div>

            <h2>User Roles and Permissions</h2>
            <table>
                <thead>
                    <tr>
                        <th>Role</th>
                        <th>Access Level</th>
                        <th>Primary Functions</th>
                        <th>Hospital ID Required</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>doctor</code></td>
                        <td>Hospital Staff</td>
                        <td>Patient consultation, emergency response, chat with staff/patients</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><code>nurse</code></td>
                        <td>Hospital Staff</td>
                        <td>Patient care coordination, chat with staff, emergency assistance</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><code>paramedic</code></td>
                        <td>Emergency Services</td>
                        <td>Emergency response, location tracking, ambulance dispatch</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><code>patient</code></td>
                        <td>External User</td>
                        <td>Emergency requests, chat with assigned medical staff</td>
                        <td>No</td>
                    </tr>
                    <tr>
                        <td><code>admin</code></td>
                        <td>Hospital Admin</td>
                        <td>System management, user oversight, full hospital access</td>
                        <td>Yes</td>
                    </tr>
                    <tr>
                        <td><code>receptionist</code></td>
                        <td>Hospital Staff</td>
                        <td>Patient coordination, appointment management, staff communication</td>
                        <td>Yes</td>
                    </tr>
                </tbody>
            </table>

            <h2>Message Flow Architecture</h2>
            <pre><code>Client (Flutter App)
    ‚Üì WebSocket Connection with Authentication
Server (Node.js + WebSocket)
    ‚Üì Message Routing by Type
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Chat System   ‚îÇ Emergency System‚îÇ Location System ‚îÇ
‚îÇ   - Messaging   ‚îÇ   - Dispatch    ‚îÇ   - GPS Track   ‚îÇ
‚îÇ   - Typing      ‚îÇ   - Response    ‚îÇ   - Sharing     ‚îÇ
‚îÇ   - Read Status ‚îÇ   - Tracking    ‚îÇ   - Updates     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
    ‚Üì Role-based Message Distribution
Hospital Staff ‚Üê ‚Üí Patients ‚Üê ‚Üí Paramedics</code></pre>
        </div>

        <!-- Section 2: Prerequisites -->
        <div id="prerequisites" class="section page-break">
            <h1>2. üìã Prerequisites & Setup</h1>

            <div class="warning-box">
                <strong>‚ö†Ô∏è Important:</strong> Ensure you have the latest Flutter SDK (3.0+) and the required permissions set up in your app before proceeding with WebSocket integration.
            </div>

            <h2>Flutter Dependencies</h2>
            <p>Add these dependencies to your <code>pubspec.yaml</code> file:</p>

            <pre><code>dependencies:
  flutter:
    sdk: flutter
  
  # WebSocket and HTTP communication
  web_socket_channel: ^2.4.0
  dio: ^5.3.2
  
  # Location and permissions
  geolocator: ^9.0.2
  permission_handler: ^11.0.1
  
  # State management and storage
  provider: ^6.1.1
  shared_preferences: ^2.2.2
  
  # Utilities
  uuid: ^4.1.0
  path_provider: ^2.1.1
  
  # Optional: For enhanced UI
  flutter_local_notifications: ^16.1.0
  connectivity_plus: ^5.0.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0</code></pre>

            <h2>Android Permissions</h2>
            <p>Add these permissions to <code>android/app/src/main/AndroidManifest.xml</code>:</p>

            <pre><code>&lt;uses-permission android:name="android.permission.INTERNET" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;
&lt;uses-permission android:name="android.permission.VIBRATE" /&gt;
&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;

&lt;!-- For file uploads in chat --&gt;
&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;
&lt;uses-permission android:name="android.permission.CAMERA" /&gt;</code></pre>

            <h2>iOS Permissions</h2>
            <p>Add these to <code>ios/Runner/Info.plist</code>:</p>

            <pre><code>&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;
&lt;string&gt;This app needs location access for emergency services and ambulance tracking.&lt;/string&gt;

&lt;key&gt;NSLocationAlwaysAndWhenInUseUsageDescription&lt;/key&gt;
&lt;string&gt;This app needs background location access for emergency tracking.&lt;/string&gt;

&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;
&lt;string&gt;This app needs camera access to share images in medical consultations.&lt;/string&gt;

&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;
&lt;string&gt;This app needs microphone access for voice messages and calls.&lt;/string&gt;</code></pre>

            <h2>Backend Server Configuration</h2>
            
            <div class="step">
                <div class="step-number">1</div>
                <div class="step-title">Server Connection Details</div>
                <p>Configure your WebSocket connection parameters:</p>
                <ul>
                    <li><strong>Development:</strong> <code>ws://localhost:5000</code></li>
                    <li><strong>Production:</strong> <code>wss://your-domain.com:5000</code></li>
                    <li><strong>Protocol:</strong> WebSocket with JSON messages</li>
                </ul>
            </div>

            <div class="step">
                <div class="step-number">2</div>
                <div class="step-title">Environment Configuration</div>
                <p>Create a configuration file for different environments:</p>
                <pre><code>// lib/config/app_config.dart
class AppConfig {
  static const String devWebSocketUrl = 'ws://localhost:5000';
  static const String prodWebSocketUrl = 'wss://api.hplus.com:5000';
  
  static String get webSocketUrl {
    return const bool.fromEnvironment('dart.vm.product') 
        ? prodWebSocketUrl 
        : devWebSocketUrl;
  }
  
  static const Duration heartbeatInterval = Duration(seconds: 30);
  static const Duration reconnectDelay = Duration(seconds: 5);
  static const int maxReconnectAttempts = 5;
}</code></pre>
            </div>

            <h2>Project Structure</h2>
            <p>Organize your Flutter project with this recommended structure:</p>

            <pre><code>lib/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ app_config.dart
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ user_model.dart
‚îÇ   ‚îú‚îÄ‚îÄ message_model.dart
‚îÇ   ‚îú‚îÄ‚îÄ emergency_model.dart
‚îÇ   ‚îî‚îÄ‚îÄ location_model.dart
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ websocket_service.dart
‚îÇ   ‚îú‚îÄ‚îÄ chat_service.dart
‚îÇ   ‚îú‚îÄ‚îÄ emergency_service.dart
‚îÇ   ‚îú‚îÄ‚îÄ location_service.dart
‚îÇ   ‚îî‚îÄ‚îÄ auth_service.dart
‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îú‚îÄ‚îÄ websocket_provider.dart
‚îÇ   ‚îú‚îÄ‚îÄ chat_provider.dart
‚îÇ   ‚îú‚îÄ‚îÄ emergency_provider.dart
‚îÇ   ‚îî‚îÄ‚îÄ location_provider.dart
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îú‚îÄ‚îÄ chat/
‚îÇ   ‚îú‚îÄ‚îÄ emergency/
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îú‚îÄ‚îÄ widgets/
‚îÇ   ‚îú‚îÄ‚îÄ chat/
‚îÇ   ‚îú‚îÄ‚îÄ emergency/
‚îÇ   ‚îî‚îÄ‚îÄ common/
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ constants.dart
    ‚îú‚îÄ‚îÄ helpers.dart
    ‚îî‚îÄ‚îÄ validators.dart</code></pre>
        </div>

        <!-- Section 3: WebSocket Connection -->
        <div id="connection" class="section page-break">
            <h1>3. üîå WebSocket Connection Setup</h1>

            <div class="info-box">
                <strong>üí° Connection Parameters:</strong> The WebSocket connection requires specific query parameters for authentication and role-based access. Each user type has different requirements.
            </div>

            <h2>Connection URL Format</h2>
            <p>The WebSocket connection URL follows this format:</p>

            <pre><code>ws://server-url:port?userId={userId}&role={role}&hospitalId={hospitalId}&department={department}&specialization={specialization}</code></pre>

            <h3>Required Parameters</h3>
            <table>
                <thead>
                    <tr>
                        <th>Parameter</th>
                        <th>Type</th>
                        <th>Required For</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>userId</code></td>
                        <td>String</td>
                        <td>All users</td>
                        <td>Unique identifier for the user</td>
                    </tr>
                    <tr>
                        <td><code>role</code></td>
                        <td>String</td>
                        <td>All users</td>
                        <td>User role (doctor, nurse, patient, etc.)</td>
                    </tr>
                    <tr>
                        <td><code>hospitalId</code></td>
                        <td>String</td>
                        <td>Hospital staff, Paramedics</td>
                        <td>Hospital identifier for staff isolation</td>
                    </tr>
                    <tr>
                        <td><code>department</code></td>
                        <td>String</td>
                        <td>Optional</td>
                        <td>Department (emergency, cardiology, etc.)</td>
                    </tr>
                    <tr>
                        <td><code>specialization</code></td>
                        <td>String</td>
                        <td>Optional</td>
                        <td>Medical specialization</td>
                    </tr>
                </tbody>
            </table>

            <h2>Flutter WebSocket Service Implementation</h2>

            <div class="step">
                <div class="step-number">1</div>
                <div class="step-title">Basic WebSocket Service</div>
                <p>Create a comprehensive WebSocket service:</p>

                <pre><code>// lib/services/websocket_service.dart
import 'dart:convert';
import 'dart:async';
import 'dart:io';
import 'package:web_socket_channel/web_socket_channel.dart';
import 'package:web_socket_channel/status.dart' as status;
import '../config/app_config.dart';

class WebSocketService {
  static final WebSocketService _instance = WebSocketService._internal();
  factory WebSocketService() => _instance;
  WebSocketService._internal();

  WebSocketChannel? _channel;
  bool _isConnected = false;
  bool _isReconnecting = false;
  int _reconnectAttempts = 0;
  Timer? _heartbeatTimer;
  Timer? _reconnectTimer;

  // Connection parameters
  String? _userId;
  String? _role;
  String? _hospitalId;
  String? _department;
  String? _specialization;

  // Stream controllers for different message types
  final _messageController = StreamController&lt;Map&lt;String, dynamic&gt;&gt;.broadcast();
  final _connectionController = StreamController&lt;bool&gt;.broadcast();
  final _errorController = StreamController&lt;String&gt;.broadcast();

  // Getters
  bool get isConnected =&gt; _isConnected;
  bool get isReconnecting =&gt; _isReconnecting;
  String? get userId =&gt; _userId;
  String? get role =&gt; _role;
  String? get hospitalId =&gt; _hospitalId;

  // Streams
  Stream&lt;Map&lt;String, dynamic&gt;&gt; get messageStream =&gt; _messageController.stream;
  Stream&lt;bool&gt; get connectionStream =&gt; _connectionController.stream;
  Stream&lt;String&gt; get errorStream =&gt; _errorController.stream;

  /// Connect to WebSocket server
  Future&lt;bool&gt; connect({
    required String userId,
    required String role,
    String? hospitalId,
    String? department,
    String? specialization,
  }) async {
    if (_isConnected) {
      print('Already connected to WebSocket');
      return true;
    }

    _userId = userId;
    _role = role;
    _hospitalId = hospitalId;
    _department = department;
    _specialization = specialization;

    try {
      final uri = _buildConnectionUri();
      print('Connecting to WebSocket: $uri');

      _channel = WebSocketChannel.connect(uri);
      
      // Wait for connection establishment
      await _channel!.ready;
      
      _isConnected = true;
      _reconnectAttempts = 0;
      _connectionController.add(true);
      
      // Setup message listener
      _setupMessageListener();
      
      // Start heartbeat
      _startHeartbeat();
      
      print('WebSocket connected successfully');
      return true;
      
    } catch (e) {
      print('WebSocket connection failed: $e');
      _errorController.add('Connection failed: $e');
      _scheduleReconnect();
      return false;
    }
  }

  /// Build connection URI with parameters
  Uri _buildConnectionUri() {
    final baseUri = Uri.parse(AppConfig.webSocketUrl);
    final queryParams = &lt;String, String&gt;{
      'userId': _userId!,
      'role': _role!,
    };

    if (_hospitalId != null) queryParams['hospitalId'] = _hospitalId!;
    if (_department != null) queryParams['department'] = _department!;
    if (_specialization != null) queryParams['specialization'] = _specialization!;

    return baseUri.replace(queryParameters: queryParams);
  }

  /// Setup message listener
  void _setupMessageListener() {
    _channel!.stream.listen(
      (data) {
        try {
          final message = json.decode(data) as Map&lt;String, dynamic&gt;;
          print('Received message: $message');
          _messageController.add(message);
        } catch (e) {
          print('Error parsing message: $e');
          _errorController.add('Message parsing error: $e');
        }
      },
      onError: (error) {
        print('WebSocket error: $error');
        _errorController.add('WebSocket error: $error');
        _handleDisconnection();
      },
      onDone: () {
        print('WebSocket connection closed');
        _handleDisconnection();
      },
    );
  }

  /// Handle connection loss
  void _handleDisconnection() {
    _isConnected = false;
    _connectionController.add(false);
    _stopHeartbeat();
    
    if (!_isReconnecting) {
      _scheduleReconnect();
    }
  }

  /// Schedule automatic reconnection
  void _scheduleReconnect() {
    if (_reconnectAttempts &gt;= AppConfig.maxReconnectAttempts) {
      print('Max reconnection attempts reached');
      _errorController.add('Unable to reconnect after ${AppConfig.maxReconnectAttempts} attempts');
      return;
    }

    _isReconnecting = true;
    _reconnectAttempts++;
    
    print('Scheduling reconnection attempt $_reconnectAttempts in ${AppConfig.reconnectDelay.inSeconds}s');
    
    _reconnectTimer?.cancel();
    _reconnectTimer = Timer(AppConfig.reconnectDelay, () {
      _attemptReconnection();
    });
  }

  /// Attempt to reconnect
  Future&lt;void&gt; _attemptReconnection() async {
    if (_isConnected) return;

    print('Attempting reconnection...');
    
    final success = await connect(
      userId: _userId!,
      role: _role!,
      hospitalId: _hospitalId,
      department: _department,
      specialization: _specialization,
    );

    if (success) {
      _isReconnecting = false;
      print('Reconnection successful');
    } else {
      _scheduleReconnect();
    }
  }

  /// Start heartbeat to keep connection alive
  void _startHeartbeat() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = Timer.periodic(AppConfig.heartbeatInterval, (_) {
      if (_isConnected) {
        sendMessage({
          'type': 'heartbeat',
          'timestamp': DateTime.now().toIso8601String(),
        });
      }
    });
  }

  /// Stop heartbeat timer
  void _stopHeartbeat() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = null;
  }

  /// Send message through WebSocket
  bool sendMessage(Map&lt;String, dynamic&gt; message) {
    if (!_isConnected || _channel == null) {
      print('Cannot send message: WebSocket not connected');
      return false;
    }

    try {
      final messageString = json.encode(message);
      _channel!.sink.add(messageString);
      print('Message sent: $message');
      return true;
    } catch (e) {
      print('Error sending message: $e');
      _errorController.add('Send error: $e');
      return false;
    }
  }

  /// Disconnect from WebSocket
  Future&lt;void&gt; disconnect() async {
    print('Disconnecting WebSocket...');
    
    _isReconnecting = false;
    _reconnectTimer?.cancel();
    _stopHeartbeat();
    
    if (_channel != null) {
      await _channel!.sink.close(status.goingAway);
      _channel = null;
    }
    
    _isConnected = false;
    _connectionController.add(false);
    print('WebSocket disconnected');
  }

  /// Dispose resources
  void dispose() {
    disconnect();
    _messageController.close();
    _connectionController.close();
    _errorController.close();
  }
}</code></pre>
            </div>

            <div class="step">
                <div class="step-number">2</div>
                <div class="step-title">Connection State Provider</div>
                <p>Create a provider to manage WebSocket state across your app:</p>

                <pre><code>// lib/providers/websocket_provider.dart
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/websocket_service.dart';

class WebSocketProvider extends ChangeNotifier {
  final WebSocketService _webSocketService = WebSocketService();
  
  bool _isConnected = false;
  bool _isConnecting = false;
  String? _error;
  String? _currentUserId;
  String? _currentRole;

  // Getters
  bool get isConnected =&gt; _isConnected;
  bool get isConnecting =&gt; _isConnecting;
  String? get error =&gt; _error;
  WebSocketService get webSocketService =&gt; _webSocketService;

  WebSocketProvider() {
    _initializeProvider();
  }

  void _initializeProvider() {
    // Listen to connection status
    _webSocketService.connectionStream.listen((connected) {
      _isConnected = connected;
      _isConnecting = false;
      notifyListeners();
    });

    // Listen to errors
    _webSocketService.errorStream.listen((error) {
      _error = error;
      _isConnecting = false;
      notifyListeners();
    });
  }

  /// Connect with user credentials
  Future&lt;bool&gt; connectUser({
    required String userId,
    required String role,
    String? hospitalId,
    String? department,
    String? specialization,
  }) async {
    if (_isConnected) return true;

    _isConnecting = true;
    _error = null;
    notifyListeners();

    try {
      final success = await _webSocketService.connect(
        userId: userId,
        role: role,
        hospitalId: hospitalId,
        department: department,
        specialization: specialization,
      );

      if (success) {
        _currentUserId = userId;
        _currentRole = role;
        await _saveConnectionInfo(userId, role, hospitalId);
      }

      return success;
    } catch (e) {
      _error = e.toString();
      _isConnecting = false;
      notifyListeners();
      return false;
    }
  }

  /// Auto-connect from saved credentials
  Future&lt;bool&gt; autoConnect() async {
    final prefs = await SharedPreferences.getInstance();
    final userId = prefs.getString('websocket_user_id');
    final role = prefs.getString('websocket_role');
    final hospitalId = prefs.getString('websocket_hospital_id');

    if (userId != null && role != null) {
      return await connectUser(
        userId: userId,
        role: role,
        hospitalId: hospitalId,
      );
    }

    return false;
  }

  /// Save connection info for auto-connect
  Future&lt;void&gt; _saveConnectionInfo(String userId, String role, String? hospitalId) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('websocket_user_id', userId);
    await prefs.setString('websocket_role', role);
    if (hospitalId != null) {
      await prefs.setString('websocket_hospital_id', hospitalId);
    }
  }

  /// Disconnect and clear saved info
  Future&lt;void&gt; disconnect() async {
    await _webSocketService.disconnect();
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('websocket_user_id');
    await prefs.remove('websocket_role');
    await prefs.remove('websocket_hospital_id');
    
    _currentUserId = null;
    _currentRole = null;
    _error = null;
    notifyListeners();
  }

  /// Clear error
  void clearError() {
    _error = null;
    notifyListeners();
  }

  @override
  void dispose() {
    _webSocketService.dispose();
    super.dispose();
  }
}</code></pre>
            </div>

            <div class="step">
                <div class="step-number">3</div>
                <div class="step-title">Connection Testing Widget</div>
                <p>Create a widget to test and monitor the WebSocket connection:</p>

                <pre><code>// lib/widgets/connection_status_widget.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/websocket_provider.dart';

class ConnectionStatusWidget extends StatelessWidget {
  const ConnectionStatusWidget({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Consumer&lt;WebSocketProvider&gt;(
      builder: (context, provider, child) {
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          decoration: BoxDecoration(
            color: _getStatusColor(provider),
            borderRadius: BorderRadius.circular(20),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                _getStatusIcon(provider),
                color: Colors.white,
                size: 16,
              ),
              const SizedBox(width: 8),
              Text(
                _getStatusText(provider),
                style: const TextStyle(
                  color: Colors.white,
                  fontWeight: FontWeight.w500,
                  fontSize: 12,
                ),
              ),
              if (provider.isConnecting) ...[
                const SizedBox(width: 8),
                const SizedBox(
                  width: 12,
                  height: 12,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    valueColor: AlwaysStoppedAnimation&lt;Color&gt;(Colors.white),
                  ),
                ),
              ],
            ],
          ),
        );
      },
    );
  }

  Color _getStatusColor(WebSocketProvider provider) {
    if (provider.isConnecting) return Colors.orange;
    if (provider.isConnected) return Colors.green;
    return Colors.red;
  }

  IconData _getStatusIcon(WebSocketProvider provider) {
    if (provider.isConnecting) return Icons.sync;
    if (provider.isConnected) return Icons.wifi;
    return Icons.wifi_off;
  }

  String _getStatusText(WebSocketProvider provider) {
    if (provider.isConnecting) return 'Connecting...';
    if (provider.isConnected) return 'Connected';
    return 'Disconnected';
  }
}</code></pre>
            </div>

            <h2>Connection Error Handling</h2>
            <div class="warning-box">
                <strong>‚ö†Ô∏è Common Connection Issues:</strong>
                <ul>
                    <li><strong>Authentication errors:</strong> Invalid userId or role parameters</li>
                    <li><strong>Network issues:</strong> Poor internet connection or server downtime</li>
                    <li><strong>Permission errors:</strong> Hospital staff missing hospitalId parameter</li>
                    <li><strong>Server overload:</strong> Too many concurrent connections</li>
                </ul>
            </div>

            <pre><code>// Example error handling in your app
void _handleWebSocketError(String error) {
  print('WebSocket Error: $error');
  
  if (error.contains('Authentication required')) {
    // Redirect to login
    _showAuthenticationDialog();
  } else if (error.contains('Hospital ID is required')) {
    // Show hospital selection
    _showHospitalSelectionDialog();
  } else if (error.contains('Unable to reconnect')) {
    // Show manual reconnect option
    _showReconnectDialog();
  }
}</code></pre>
        </div>        <!-- Section 4: Authentication & User Roles -->
        <div class="section page-break" id="authentication">
            <h1>4. üîê Authentication & User Roles</h1>
            
            <h2>User Role Types</h2>
            <div class="info-box">
                <strong>üìù HPlus System Roles:</strong>
                <ul>
                    <li><strong>patient:</strong> Individual seeking medical care</li>
                    <li><strong>doctor:</strong> Medical professional providing care</li>
                    <li><strong>nurse:</strong> Healthcare support staff</li>
                    <li><strong>admin:</strong> Hospital administrator</li>
                    <li><strong>emergency:</strong> Emergency response personnel</li>
                </ul>
            </div>

            <h2>Authentication Implementation</h2>
            <pre><code>class AuthService {
  static const String _baseUrl = 'https://your-api-server.com';
  
  static Future&lt;Map&lt;String, dynamic&gt;&gt; authenticateUser(
    String email, 
    String password
  ) async {
    try {
      final response = await http.post(
        Uri.parse('$_baseUrl/auth/login'),
        headers: {'Content-Type': 'application/json'},
        body: json.encode({
          'email': email,
          'password': password,
        }),
      );

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        
        // Store user credentials
        await _storeUserCredentials(data);
        
        return {
          'success': true,
          'user': data['user'],
          'token': data['token'],
        };
      } else {
        return {
          'success': false,
          'error': 'Invalid credentials',
        };
      }
    } catch (e) {
      return {
        'success': false,
        'error': 'Network error: $e',
      };
    }
  }

  static Future&lt;void&gt; _storeUserCredentials(Map&lt;String, dynamic&gt; data) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('user_id', data['user']['id']);
    await prefs.setString('user_role', data['user']['role']);
    await prefs.setString('auth_token', data['token']);
    
    // Store hospital ID for hospital staff
    if (data['user']['hospitalId'] != null) {
      await prefs.setString('hospital_id', data['user']['hospitalId']);
    }
  }
}</code></pre>

            <h2>Role-Based Connection Parameters</h2>
            <pre><code>class WebSocketService {
  Future&lt;void&gt; connectWithUserRole() async {
    final prefs = await SharedPreferences.getInstance();
    final userId = prefs.getString('user_id');
    final userRole = prefs.getString('user_role');
    final hospitalId = prefs.getString('hospital_id');

    if (userId == null || userRole == null) {
      throw Exception('User not authenticated');
    }

    Map&lt;String, String&gt; queryParams = {
      'userId': userId,
      'role': userRole,
    };

    // Add hospital ID for hospital staff
    if (['doctor', 'nurse', 'admin'].contains(userRole) && hospitalId != null) {
      queryParams['hospitalId'] = hospitalId;
    }

    final uri = Uri.parse('ws://localhost:5000').replace(
      queryParameters: queryParams,
    );

    await connect(uri.toString());
  }
}</code></pre>
        </div>        <!-- Section 5: Chat System Implementation -->
        <div class="section page-break" id="chat-system">
            <h1>5. üí¨ Chat System Implementation</h1>
            
            <h2>Chat Message Model</h2>
            <pre><code>class ChatMessage {
  final String id;
  final String senderId;
  final String senderName;
  final String senderRole;
  final String recipientId;
  final String content;
  final String type;
  final DateTime timestamp;
  final bool isRead;
  final Map&lt;String, dynamic&gt;? metadata;

  ChatMessage({
    required this.id,
    required this.senderId,
    required this.senderName,
    required this.senderRole,
    required this.recipientId,
    required this.content,
    required this.type,
    required this.timestamp,
    this.isRead = false,
    this.metadata,
  });

  factory ChatMessage.fromJson(Map&lt;String, dynamic&gt; json) {
    return ChatMessage(
      id: json['id'],
      senderId: json['senderId'],
      senderName: json['senderName'],
      senderRole: json['senderRole'],
      recipientId: json['recipientId'],
      content: json['content'],
      type: json['type'],
      timestamp: DateTime.parse(json['timestamp']),
      isRead: json['isRead'] ?? false,
      metadata: json['metadata'],
    );
  }

  Map&lt;String, dynamic&gt; toJson() {
    return {
      'id': id,
      'senderId': senderId,
      'senderName': senderName,
      'senderRole': senderRole,
      'recipientId': recipientId,
      'content': content,
      'type': type,
      'timestamp': timestamp.toIso8601String(),
      'isRead': isRead,
      'metadata': metadata,
    };
  }
}</code></pre>

            <h2>Chat Service Provider</h2>
            <pre><code>class ChatProvider extends ChangeNotifier {
  final WebSocketService _webSocketService = WebSocketService();
  final List&lt;ChatMessage&gt; _messages = [];
  final Map&lt;String, List&lt;ChatMessage&gt;&gt; _conversations = {};
  
  List&lt;ChatMessage&gt; get messages =&gt; List.unmodifiable(_messages);
  Map&lt;String, List&lt;ChatMessage&gt;&gt; get conversations =&gt; Map.unmodifiable(_conversations);

  void initialize() {
    _webSocketService.messageStream.listen((data) {
      if (data['type'] == 'chat_message') {
        _handleChatMessage(data);
      } else if (data['type'] == 'message_read') {
        _handleMessageRead(data);
      }
    });
  }

  void _handleChatMessage(Map&lt;String, dynamic&gt; data) {
    final message = ChatMessage.fromJson(data['payload']);
    _messages.add(message);
    
    // Organize by conversation
    final conversationKey = _getConversationKey(message.senderId, message.recipientId);
    _conversations.putIfAbsent(conversationKey, () =&gt; []);
    _conversations[conversationKey]!.add(message);
    
    notifyListeners();
  }

  void _handleMessageRead(Map&lt;String, dynamic&gt; data) {
    final messageId = data['payload']['messageId'];
    final messageIndex = _messages.indexWhere((m) =&gt; m.id == messageId);
    
    if (messageIndex != -1) {
      final message = _messages[messageIndex];
      _messages[messageIndex] = ChatMessage(
        id: message.id,
        senderId: message.senderId,
        senderName: message.senderName,
        senderRole: message.senderRole,
        recipientId: message.recipientId,
        content: message.content,
        type: message.type,
        timestamp: message.timestamp,
        isRead: true,
        metadata: message.metadata,
      );
      notifyListeners();
    }
  }

  Future&lt;void&gt; sendMessage(String recipientId, String content, {String type = 'text'}) async {
    final messageData = {
      'type': 'send_message',
      'payload': {
        'recipientId': recipientId,
        'content': content,
        'messageType': type,
        'timestamp': DateTime.now().toIso8601String(),
      },
    };

    _webSocketService.sendMessage(messageData);
  }

  Future&lt;void&gt; markMessageAsRead(String messageId) async {
    final data = {
      'type': 'mark_message_read',
      'payload': {
        'messageId': messageId,
      },
    };

    _webSocketService.sendMessage(data);
  }

  String _getConversationKey(String userId1, String userId2) {
    final users = [userId1, userId2]..sort();
    return users.join('_');
  }

  List&lt;ChatMessage&gt; getConversation(String otherUserId, String currentUserId) {
    final key = _getConversationKey(otherUserId, currentUserId);
    return _conversations[key] ?? [];
  }
}</code></pre>

            <h2>Chat UI Widget</h2>
            <pre><code>class ChatScreen extends StatefulWidget {
  final String recipientId;
  final String recipientName;

  const ChatScreen({
    Key? key,
    required this.recipientId,
    required this.recipientName,
  }) : super(key: key);

  @override
  _ChatScreenState createState() =&gt; _ChatScreenState();
}

class _ChatScreenState extends State&lt;ChatScreen&gt; {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.recipientName),
        backgroundColor: Colors.blue[600],
      ),
      body: Column(
        children: [
          Expanded(
            child: Consumer&lt;ChatProvider&gt;(
              builder: (context, chatProvider, child) {
                final currentUserId = context.read&lt;UserProvider&gt;().currentUser?.id ?? '';
                final messages = chatProvider.getConversation(widget.recipientId, currentUserId);

                return ListView.builder(
                  controller: _scrollController,
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final message = messages[index];
                    final isOwn = message.senderId == currentUserId;

                    return _buildMessageBubble(message, isOwn);
                  },
                );
              },
            ),
          ),
          _buildMessageInput(),
        ],
      ),
    );
  }

  Widget _buildMessageBubble(ChatMessage message, bool isOwn) {
    return Container(
      margin: EdgeInsets.symmetric(vertical: 4, horizontal: 8),
      child: Row(
        mainAxisAlignment: isOwn ? MainAxisAlignment.end : MainAxisAlignment.start,
        children: [
          if (!isOwn) _buildAvatar(message.senderRole),
          Flexible(
            child: Container(
              padding: EdgeInsets.symmetric(vertical: 10, horizontal: 14),
              decoration: BoxDecoration(
                color: isOwn ? Colors.blue[600] : Colors.grey[300],
                borderRadius: BorderRadius.circular(20),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (!isOwn)
                    Text(
                      message.senderName,
                      style: TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                        color: Colors.grey[600],
                      ),
                    ),
                  Text(
                    message.content,
                    style: TextStyle(
                      color: isOwn ? Colors.white : Colors.black87,
                    ),
                  ),
                  SizedBox(height: 4),
                  Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        _formatTime(message.timestamp),
                        style: TextStyle(
                          fontSize: 10,
                          color: isOwn ? Colors.white70 : Colors.grey[600],
                        ),
                      ),
                      if (isOwn) ...[
                        SizedBox(width: 4),
                        Icon(
                          message.isRead ? Icons.done_all : Icons.done,
                          size: 12,
                          color: message.isRead ? Colors.green : Colors.white70,
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),
          if (isOwn) _buildAvatar(message.senderRole),
        ],
      ),
    );
  }

  Widget _buildAvatar(String role) {
    IconData icon;
    Color color;

    switch (role) {
      case 'doctor':
        icon = Icons.medical_services;
        color = Colors.blue;
        break;
      case 'nurse':
        icon = Icons.local_hospital;
        color = Colors.green;
        break;
      case 'patient':
        icon = Icons.person;
        color = Colors.orange;
        break;
      default:
        icon = Icons.person;
        color = Colors.grey;
    }

    return Container(
      width: 32,
      height: 32,
      margin: EdgeInsets.symmetric(horizontal: 8),
      decoration: BoxDecoration(
        color: color,
        shape: BoxShape.circle,
      ),
      child: Icon(icon, color: Colors.white, size: 16),
    );
  }

  Widget _buildMessageInput() {
    return Container(
      padding: EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            offset: Offset(0, -2),
            blurRadius: 6,
            color: Colors.black12,
          ),
        ],
      ),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _messageController,
              decoration: InputDecoration(
                hintText: 'Type a message...',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(25),
                ),
                contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              ),
              maxLines: null,
            ),
          ),
          SizedBox(width: 8),
          FloatingActionButton.small(
            onPressed: _sendMessage,
            backgroundColor: Colors.blue[600],
            child: Icon(Icons.send, color: Colors.white),
          ),
        ],
      ),
    );
  }

  void _sendMessage() {
    final content = _messageController.text.trim();
    if (content.isNotEmpty) {
      context.read&lt;ChatProvider&gt;().sendMessage(widget.recipientId, content);
      _messageController.clear();
      
      // Scroll to bottom
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _scrollController.animateTo(
          _scrollController.position.maxScrollExtent,
          duration: Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      });
    }
  }

  String _formatTime(DateTime timestamp) {
    return '${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}';
  }
}</code></pre>
        </div>        <!-- Section 6: Emergency System Implementation -->
        <div class="section page-break" id="emergency-system">
            <h1>6. üö® Emergency System Implementation</h1>
            
            <h2>Emergency Alert Model</h2>
            <pre><code>class EmergencyAlert {
  final String id;
  final String patientId;
  final String patientName;
  final String type;
  final String severity;
  final String description;
  final Map&lt;String, double&gt; location;
  final DateTime timestamp;
  final String status;
  final String? assignedToId;
  final String? assignedToName;
  final Map&lt;String, dynamic&gt;? metadata;

  EmergencyAlert({
    required this.id,
    required this.patientId,
    required this.patientName,
    required this.type,
    required this.severity,
    required this.description,
    required this.location,
    required this.timestamp,
    required this.status,
    this.assignedToId,
    this.assignedToName,
    this.metadata,
  });

  factory EmergencyAlert.fromJson(Map&lt;String, dynamic&gt; json) {
    return EmergencyAlert(
      id: json['id'],
      patientId: json['patientId'],
      patientName: json['patientName'],
      type: json['type'],
      severity: json['severity'],
      description: json['description'],
      location: Map&lt;String, double&gt;.from(json['location']),
      timestamp: DateTime.parse(json['timestamp']),
      status: json['status'],
      assignedToId: json['assignedToId'],
      assignedToName: json['assignedToName'],
      metadata: json['metadata'],
    );
  }
}</code></pre>

            <h2>Emergency Service Provider</h2>
            <pre><code>class EmergencyProvider extends ChangeNotifier {
  final WebSocketService _webSocketService = WebSocketService();
  final List&lt;EmergencyAlert&gt; _activeAlerts = [];
  EmergencyAlert? _currentAlert;
  
  List&lt;EmergencyAlert&gt; get activeAlerts =&gt; List.unmodifiable(_activeAlerts);
  EmergencyAlert? get currentAlert =&gt; _currentAlert;

  void initialize() {
    _webSocketService.messageStream.listen((data) {
      switch (data['type']) {
        case 'emergency_alert':
          _handleEmergencyAlert(data);
          break;
        case 'emergency_update':
          _handleEmergencyUpdate(data);
          break;
        case 'emergency_assigned':
          _handleEmergencyAssigned(data);
          break;
        case 'emergency_resolved':
          _handleEmergencyResolved(data);
          break;
      }
    });
  }

  void _handleEmergencyAlert(Map&lt;String, dynamic&gt; data) {
    final alert = EmergencyAlert.fromJson(data['payload']);
    _activeAlerts.add(alert);
    
    // Show notification
    _showEmergencyNotification(alert);
    
    notifyListeners();
  }

  void _handleEmergencyUpdate(Map&lt;String, dynamic&gt; data) {
    final alertId = data['payload']['alertId'];
    final updates = data['payload']['updates'];
    
    final index = _activeAlerts.indexWhere((alert) =&gt; alert.id == alertId);
    if (index != -1) {
      // Update alert with new information
      // Implementation would depend on your specific update structure
      notifyListeners();
    }
  }

  Future&lt;void&gt; createEmergencyAlert({
    required String type,
    required String severity,
    required String description,
    Map&lt;String, double&gt;? location,
  }) async {
    final alertData = {
      'type': 'create_emergency',
      'payload': {
        'alertType': type,
        'severity': severity,
        'description': description,
        'location': location ?? await _getCurrentLocation(),
        'timestamp': DateTime.now().toIso8601String(),
      },
    };

    _webSocketService.sendMessage(alertData);
  }

  Future&lt;void&gt; acceptEmergencyAlert(String alertId) async {
    final data = {
      'type': 'accept_emergency',
      'payload': {
        'alertId': alertId,
      },
    };

    _webSocketService.sendMessage(data);
  }

  Future&lt;void&gt; updateEmergencyStatus(String alertId, String status, {String? notes}) async {
    final data = {
      'type': 'update_emergency_status',
      'payload': {
        'alertId': alertId,
        'status': status,
        'notes': notes,
        'timestamp': DateTime.now().toIso8601String(),
      },
    };

    _webSocketService.sendMessage(data);
  }

  Future&lt;Map&lt;String, double&gt;&gt; _getCurrentLocation() async {
    // Implementation for getting current location
    final position = await Geolocator.getCurrentPosition();
    return {
      'latitude': position.latitude,
      'longitude': position.longitude,
    };
  }

  void _showEmergencyNotification(EmergencyAlert alert) {
    // Show system notification
    final NotificationService = locator&lt;NotificationService&gt;();
    NotificationService.showEmergencyNotification(
      title: 'Emergency Alert: ${alert.type}',
      body: '${alert.patientName} - ${alert.description}',
      data: {'alertId': alert.id, 'type': 'emergency'},
    );
  }
}</code></pre>

            <h2>Emergency Alert Widget</h2>
            <pre><code>class EmergencyAlertCard extends StatelessWidget {
  final EmergencyAlert alert;
  final VoidCallback? onAccept;
  final VoidCallback? onViewDetails;

  const EmergencyAlertCard({
    Key? key,
    required this.alert,
    this.onAccept,
    this.onViewDetails,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: EdgeInsets.all(8),
      elevation: 4,
      color: _getSeverityColor(alert.severity),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(
                  _getEmergencyIcon(alert.type),
                  color: Colors.white,
                  size: 24,
                ),
                SizedBox(width: 8),
                Expanded(
                  child: Text(
                    alert.type.toUpperCase(),
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                Container(
                  padding: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                  decoration: BoxDecoration(
                    color: Colors.white.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    alert.severity,
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),
            SizedBox(height: 12),
            Text(
              'Patient: ${alert.patientName}',
              style: TextStyle(
                color: Colors.white,
                fontSize: 16,
                fontWeight: FontWeight.w500,
              ),
            ),
            SizedBox(height: 8),
            Text(
              alert.description,
              style: TextStyle(
                color: Colors.white.withOpacity(0.9),
                fontSize: 14,
              ),
            ),
            SizedBox(height: 12),
            Row(
              children: [
                Icon(Icons.access_time, color: Colors.white, size: 16),
                SizedBox(width: 4),
                Text(
                  _formatTimestamp(alert.timestamp),
                  style: TextStyle(
                    color: Colors.white.withOpacity(0.8),
                    fontSize: 12,
                  ),
                ),
                Spacer(),
                if (alert.assignedToId == null && onAccept != null)
                  ElevatedButton(
                    onPressed: onAccept,
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.white,
                      foregroundColor: _getSeverityColor(alert.severity),
                    ),
                    child: Text('Accept'),
                  ),
                SizedBox(width: 8),
                ElevatedButton(
                  onPressed: onViewDetails,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.white.withOpacity(0.2),
                    foregroundColor: Colors.white,
                  ),
                  child: Text('Details'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Color _getSeverityColor(String severity) {
    switch (severity.toLowerCase()) {
      case 'critical':
        return Colors.red[700]!;
      case 'high':
        return Colors.orange[700]!;
      case 'medium':
        return Colors.yellow[700]!;
      case 'low':
        return Colors.blue[700]!;
      default:
        return Colors.grey[700]!;
    }
  }

  IconData _getEmergencyIcon(String type) {
    switch (type.toLowerCase()) {
      case 'cardiac':
        return Icons.favorite;
      case 'respiratory':
        return Icons.air;
      case 'trauma':
        return Icons.local_hospital;
      case 'neurological':
        return Icons.psychology;
      case 'overdose':
        return Icons.warning;
      default:
        return Icons.emergency;
    }
  }

  String _formatTimestamp(DateTime timestamp) {
    final now = DateTime.now();
    final difference = now.difference(timestamp);
    
    if (difference.inMinutes &lt; 1) {
      return 'Just now';
    } else if (difference.inMinutes &lt; 60) {
      return '${difference.inMinutes}m ago';
    } else {
      return '${difference.inHours}h ago';
    }
  }
}</code></pre>
        </div>        <!-- Section 7: Real-time Location Sharing -->
        <div class="section page-break" id="location-sharing">
            <h1>7. üìç Real-time Location Sharing</h1>
            
            <h2>Location Service Setup</h2>
            <div class="warning-box">
                <strong>‚ö†Ô∏è Location Permissions Required:</strong>
                <p>Add the following permissions to your <code>android/app/src/main/AndroidManifest.xml</code>:</p>
                <pre><code>&lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;
&lt;uses-permission android:name="android.permission.ACCESS_BACKGROUND_LOCATION" /&gt;</code></pre>
            </div>

            <pre><code>class LocationService {
  static LocationService? _instance;
  static LocationService get instance =&gt; _instance ??= LocationService._();
  LocationService._();

  StreamSubscription&lt;Position&gt;? _positionSubscription;
  final WebSocketService _webSocketService = WebSocketService();

  Future&lt;bool&gt; initializeLocationTracking() async {
    // Check permissions
    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        return false;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      return false;
    }

    // Check location services
    bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      return false;
    }

    return true;
  }

  Future&lt;void&gt; startLocationSharing({
    int intervalSeconds = 30,
    double distanceFilter = 10.0,
  }) async {
    final hasPermission = await initializeLocationTracking();
    if (!hasPermission) {
      throw Exception('Location permission denied');
    }

    const LocationSettings locationSettings = LocationSettings(
      accuracy: LocationAccuracy.high,
      distanceFilter: 10,
    );

    _positionSubscription = Geolocator.getPositionStream(
      locationSettings: locationSettings,
    ).listen((Position position) {
      _shareLocation(position);
    });
  }

  void _shareLocation(Position position) {
    final locationData = {
      'type': 'location_update',
      'payload': {
        'latitude': position.latitude,
        'longitude': position.longitude,
        'accuracy': position.accuracy,
        'altitude': position.altitude,
        'speed': position.speed,
        'heading': position.heading,
        'timestamp': DateTime.now().toIso8601String(),
      },
    };

    _webSocketService.sendMessage(locationData);
  }

  Future&lt;Position&gt; getCurrentLocation() async {
    final hasPermission = await initializeLocationTracking();
    if (!hasPermission) {
      throw Exception('Location permission denied');
    }

    return await Geolocator.getCurrentPosition(
      desiredAccuracy: LocationAccuracy.high,
    );
  }

  void stopLocationSharing() {
    _positionSubscription?.cancel();
    _positionSubscription = null;
  }

  Future&lt;void&gt; shareEmergencyLocation() async {
    try {
      final position = await getCurrentLocation();
      final emergencyLocationData = {
        'type': 'emergency_location',
        'payload': {
          'latitude': position.latitude,
          'longitude': position.longitude,
          'accuracy': position.accuracy,
          'timestamp': DateTime.now().toIso8601String(),
          'isEmergency': true,
        },
      };

      _webSocketService.sendMessage(emergencyLocationData);
    } catch (e) {
      print('Error sharing emergency location: $e');
    }
  }
}</code></pre>

            <h2>Location Provider</h2>
            <pre><code>class LocationProvider extends ChangeNotifier {
  final WebSocketService _webSocketService = WebSocketService();
  final Map&lt;String, UserLocation&gt; _userLocations = {};
  UserLocation? _currentUserLocation;
  bool _isSharing = false;

  Map&lt;String, UserLocation&gt; get userLocations =&gt; Map.unmodifiable(_userLocations);
  UserLocation? get currentUserLocation =&gt; _currentUserLocation;
  bool get isSharing =&gt; _isSharing;

  void initialize() {
    _webSocketService.messageStream.listen((data) {
      switch (data['type']) {
        case 'location_update':
          _handleLocationUpdate(data);
          break;
        case 'user_location_list':
          _handleLocationList(data);
          break;
        case 'emergency_location':
          _handleEmergencyLocation(data);
          break;
      }
    });
  }

  void _handleLocationUpdate(Map&lt;String, dynamic&gt; data) {
    final location = UserLocation.fromJson(data['payload']);
    _userLocations[location.userId] = location;
    notifyListeners();
  }

  void _handleLocationList(Map&lt;String, dynamic&gt; data) {
    final locations = data['payload']['locations'] as List;
    _userLocations.clear();
    
    for (final locationData in locations) {
      final location = UserLocation.fromJson(locationData);
      _userLocations[location.userId] = location;
    }
    
    notifyListeners();
  }

  void _handleEmergencyLocation(Map&lt;String, dynamic&gt; data) {
    final location = UserLocation.fromJson(data['payload']);
    _userLocations[location.userId] = location;
    
    // Show emergency location notification
    _showEmergencyLocationAlert(location);
    
    notifyListeners();
  }

  Future&lt;void&gt; startLocationSharing() async {
    try {
      await LocationService.instance.startLocationSharing();
      _isSharing = true;
      notifyListeners();
    } catch (e) {
      print('Error starting location sharing: $e');
      rethrow;
    }
  }

  void stopLocationSharing() {
    LocationService.instance.stopLocationSharing();
    _isSharing = false;
    notifyListeners();
  }

  Future&lt;void&gt; requestNearbyUsers(double radiusKm) async {
    try {
      final currentPosition = await LocationService.instance.getCurrentLocation();
      
      final requestData = {
        'type': 'request_nearby_users',
        'payload': {
          'latitude': currentPosition.latitude,
          'longitude': currentPosition.longitude,
          'radiusKm': radiusKm,
        },
      };

      _webSocketService.sendMessage(requestData);
    } catch (e) {
      print('Error requesting nearby users: $e');
    }
  }

  void _showEmergencyLocationAlert(UserLocation location) {
    // Implementation for showing emergency location alert
    final NotificationService = locator&lt;NotificationService&gt;();
    NotificationService.showLocationAlert(
      title: 'Emergency Location Shared',
      body: '${location.userName} has shared their emergency location',
      data: {'userId': location.userId, 'type': 'emergency_location'},
    );
  }

  double calculateDistance(UserLocation location1, UserLocation location2) {
    return Geolocator.distanceBetween(
      location1.latitude,
      location1.longitude,
      location2.latitude,
      location2.longitude,
    );
  }
}</code></pre>

            <h2>Location Model</h2>
            <pre><code>class UserLocation {
  final String userId;
  final String userName;
  final String userRole;
  final double latitude;
  final double longitude;
  final double? accuracy;
  final double? altitude;
  final double? speed;
  final double? heading;
  final DateTime timestamp;
  final bool isEmergency;
  final Map&lt;String, dynamic&gt;? metadata;

  UserLocation({
    required this.userId,
    required this.userName,
    required this.userRole,
    required this.latitude,
    required this.longitude,
    this.accuracy,
    this.altitude,
    this.speed,
    this.heading,
    required this.timestamp,
    this.isEmergency = false,
    this.metadata,
  });

  factory UserLocation.fromJson(Map&lt;String, dynamic&gt; json) {
    return UserLocation(
      userId: json['userId'],
      userName: json['userName'],
      userRole: json['userRole'],
      latitude: json['latitude'].toDouble(),
      longitude: json['longitude'].toDouble(),
      accuracy: json['accuracy']?.toDouble(),
      altitude: json['altitude']?.toDouble(),
      speed: json['speed']?.toDouble(),
      heading: json['heading']?.toDouble(),
      timestamp: DateTime.parse(json['timestamp']),
      isEmergency: json['isEmergency'] ?? false,
      metadata: json['metadata'],
    );
  }

  Map&lt;String, dynamic&gt; toJson() {
    return {
      'userId': userId,
      'userName': userName,
      'userRole': userRole,
      'latitude': latitude,
      'longitude': longitude,
      'accuracy': accuracy,
      'altitude': altitude,
      'speed': speed,
      'heading': heading,
      'timestamp': timestamp.toIso8601String(),
      'isEmergency': isEmergency,
      'metadata': metadata,
    };
  }
}</code></pre>
        </div>        <!-- Section 8: Message Types & Data Structures -->
        <div class="section page-break" id="message-types">
            <h1>8. üìã Message Types & Data Structures</h1>
            
            <h2>WebSocket Message Protocol</h2>
            <div class="info-box">
                <strong>üìã Message Format:</strong>
                <p>All WebSocket messages follow this structure:</p>
                <pre><code>{
  "type": "message_type",
  "payload": {
    // Message-specific data
  },
  "timestamp": "2024-01-15T10:30:00.000Z"
}</code></pre>
            </div>

            <h2>Outgoing Message Types</h2>
            <div class="message-section">
                <h3>1. Send Chat Message</h3>
                <pre><code>{
  "type": "send_message",
  "payload": {
    "recipientId": "user123",
    "content": "Hello, how are you?",
    "messageType": "text", // text, image, file, location
    "metadata": {
      "urgency": "normal" // normal, high, emergency
    }
  }
}</code></pre>

                <h3>2. Mark Message as Read</h3>
                <pre><code>{
  "type": "mark_message_read",
  "payload": {
    "messageId": "msg456"
  }
}</code></pre>

                <h3>3. Create Emergency Alert</h3>
                <pre><code>{
  "type": "create_emergency",
  "payload": {
    "alertType": "cardiac", // cardiac, respiratory, trauma, etc.
    "severity": "critical", // low, medium, high, critical
    "description": "Patient experiencing chest pain",
    "location": {
      "latitude": 40.7128,
      "longitude": -74.0060
    },
    "vitals": {
      "heartRate": 120,
      "bloodPressure": "140/90",
      "oxygenSaturation": 95
    }
  }
}</code></pre>

                <h3>4. Accept Emergency</h3>
                <pre><code>{
  "type": "accept_emergency",
  "payload": {
    "alertId": "emergency123"
  }
}</code></pre>

                <h3>5. Update Emergency Status</h3>
                <pre><code>{
  "type": "update_emergency_status",
  "payload": {
    "alertId": "emergency123",
    "status": "en_route", // pending, accepted, en_route, on_scene, resolved
    "notes": "ETA 5 minutes",
    "location": {
      "latitude": 40.7130,
      "longitude": -74.0058
    }
  }
}</code></pre>

                <h3>6. Share Location</h3>
                <pre><code>{
  "type": "location_update",
  "payload": {
    "latitude": 40.7128,
    "longitude": -74.0060,
    "accuracy": 5.0,
    "altitude": 10.0,
    "speed": 0.0,
    "heading": 180.0
  }
}</code></pre>

                <h3>7. Request Nearby Users</h3>
                <pre><code>{
  "type": "request_nearby_users",
  "payload": {
    "latitude": 40.7128,
    "longitude": -74.0060,
    "radiusKm": 5.0,
    "userTypes": ["doctor", "nurse", "emergency"] // Optional filter
  }
}</code></pre>

                <h3>8. Join Room/Channel</h3>
                <pre><code>{
  "type": "join_room",
  "payload": {
    "roomId": "emergency_dispatch_room",
    "roomType": "emergency" // chat, emergency, announcement
  }
}</code></pre>

                <h3>9. Leave Room/Channel</h3>
                <pre><code>{
  "type": "leave_room",
  "payload": {
    "roomId": "emergency_dispatch_room"
  }
}</code></pre>

                <h3>10. Update User Status</h3>
                <pre><code>{
  "type": "update_status",
  "payload": {
    "status": "available", // available, busy, away, emergency
    "customMessage": "On duty until 6 PM"
  }
}</code></pre>
            </div>

            <h2>Incoming Message Types</h2>
            <div class="message-section">
                <h3>1. Chat Message Received</h3>
                <pre><code>{
  "type": "chat_message",
  "payload": {
    "id": "msg123",
    "senderId": "user456",
    "senderName": "Dr. Smith",
    "senderRole": "doctor",
    "recipientId": "user789",
    "content": "Patient in room 301 needs attention",
    "messageType": "text",
    "timestamp": "2024-01-15T10:30:00.000Z",
    "metadata": {
      "urgency": "high",
      "hospitalId": "hospital123"
    }
  }
}</code></pre>

                <h3>2. Emergency Alert</h3>
                <pre><code>{
  "type": "emergency_alert",
  "payload": {
    "id": "emergency123",
    "patientId": "patient456",
    "patientName": "John Doe",
    "type": "cardiac",
    "severity": "critical",
    "description": "Cardiac arrest in ER",
    "location": {
      "latitude": 40.7128,
      "longitude": -74.0060,
      "address": "123 Hospital St, New York, NY"
    },
    "timestamp": "2024-01-15T10:30:00.000Z",
    "status": "pending",
    "requiredSpecialties": ["cardiology", "emergency"],
    "estimatedResponseTime": 300
  }
}</code></pre>

                <h3>3. Emergency Assignment</h3>
                <pre><code>{
  "type": "emergency_assigned",
  "payload": {
    "alertId": "emergency123",
    "assignedToId": "doctor456",
    "assignedToName": "Dr. Johnson",
    "assignedRole": "doctor",
    "timestamp": "2024-01-15T10:32:00.000Z"
  }
}</code></pre>

                <h3>4. Location Update</h3>
                <pre><code>{
  "type": "location_update",
  "payload": {
    "userId": "user123",
    "userName": "Nurse Kate",
    "userRole": "nurse",
    "latitude": 40.7128,
    "longitude": -74.0060,
    "accuracy": 5.0,
    "timestamp": "2024-01-15T10:30:00.000Z",
    "isEmergency": false
  }
}</code></pre>

                <h3>5. User Status Change</h3>
                <pre><code>{
  "type": "user_status_change",
  "payload": {
    "userId": "user123",
    "userName": "Dr. Smith",
    "oldStatus": "available",
    "newStatus": "busy",
    "customMessage": "In surgery",
    "timestamp": "2024-01-15T10:30:00.000Z"
  }
}</code></pre>

                <h3>6. System Notification</h3>
                <pre><code>{
  "type": "system_notification",
  "payload": {
    "id": "notif123",
    "title": "System Maintenance",
    "message": "System will be down for maintenance at 2 AM",
    "severity": "info", // info, warning, error
    "targetRoles": ["all"], // or specific roles
    "timestamp": "2024-01-15T10:30:00.000Z",
    "expiresAt": "2024-01-16T10:30:00.000Z"
  }
}</code></pre>

                <h3>7. Message Read Receipt</h3>
                <pre><code>{
  "type": "message_read",
  "payload": {
    "messageId": "msg123",
    "readBy": "user456",
    "readAt": "2024-01-15T10:35:00.000Z"
  }
}</code></pre>

                <h3>8. User Connected/Disconnected</h3>
                <pre><code>{
  "type": "user_connection_change",
  "payload": {
    "userId": "user123",
    "userName": "Dr. Smith",
    "userRole": "doctor",
    "isConnected": true,
    "timestamp": "2024-01-15T10:30:00.000Z"
  }
}</code></pre>
            </div>

            <h2>Error Message Format</h2>
            <pre><code>{
  "type": "error",
  "payload": {
    "code": "AUTH_REQUIRED",
    "message": "Authentication required to access this resource",
    "details": {
      "requiredRole": "doctor",
      "currentRole": null
    },
    "timestamp": "2024-01-15T10:30:00.000Z"
  }
}</code></pre>

            <h2>Common Error Codes</h2>
            <div class="warning-box">
                <strong>üîç Error Code Reference:</strong>
                <ul>
                    <li><strong>AUTH_REQUIRED:</strong> User authentication required</li>
                    <li><strong>INVALID_ROLE:</strong> User role not authorized for action</li>
                    <li><strong>HOSPITAL_ID_REQUIRED:</strong> Hospital staff must provide hospital ID</li>
                    <li><strong>INVALID_MESSAGE_FORMAT:</strong> Message format is incorrect</li>
                    <li><strong>RECIPIENT_NOT_FOUND:</strong> Message recipient does not exist</li>
                    <li><strong>EMERGENCY_NOT_FOUND:</strong> Emergency alert does not exist</li>
                    <li><strong>LOCATION_PERMISSION_DENIED:</strong> Location access not granted</li>
                    <li><strong>RATE_LIMIT_EXCEEDED:</strong> Too many messages sent</li>
                </ul>
            </div>
        </div>        <!-- Section 9: Complete Flutter Implementation Examples -->
        <div class="section page-break" id="flutter-examples">
            <h1>9. üì± Complete Flutter Implementation Examples</h1>
            
            <h2>Complete Application Structure</h2>
            <pre><code>lib/
‚îú‚îÄ‚îÄ main.dart
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ chat_message.dart
‚îÇ   ‚îú‚îÄ‚îÄ emergency_alert.dart
‚îÇ   ‚îú‚îÄ‚îÄ user_location.dart
‚îÇ   ‚îî‚îÄ‚îÄ user.dart
‚îú‚îÄ‚îÄ providers/
‚îÇ   ‚îú‚îÄ‚îÄ websocket_provider.dart
‚îÇ   ‚îú‚îÄ‚îÄ chat_provider.dart
‚îÇ   ‚îú‚îÄ‚îÄ emergency_provider.dart
‚îÇ   ‚îú‚îÄ‚îÄ location_provider.dart
‚îÇ   ‚îî‚îÄ‚îÄ user_provider.dart
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ websocket_service.dart
‚îÇ   ‚îú‚îÄ‚îÄ auth_service.dart
‚îÇ   ‚îú‚îÄ‚îÄ location_service.dart
‚îÇ   ‚îî‚îÄ‚îÄ notification_service.dart
‚îú‚îÄ‚îÄ screens/
‚îÇ   ‚îú‚îÄ‚îÄ dashboard_screen.dart
‚îÇ   ‚îú‚îÄ‚îÄ chat_screen.dart
‚îÇ   ‚îú‚îÄ‚îÄ emergency_screen.dart
‚îÇ   ‚îú‚îÄ‚îÄ location_screen.dart
‚îÇ   ‚îî‚îÄ‚îÄ login_screen.dart
‚îî‚îÄ‚îÄ widgets/
    ‚îú‚îÄ‚îÄ connection_status_widget.dart
    ‚îú‚îÄ‚îÄ emergency_alert_card.dart
    ‚îú‚îÄ‚îÄ chat_message_bubble.dart
    ‚îî‚îÄ‚îÄ location_map_widget.dart</code></pre>

            <h2>Complete Main Application Setup</h2>
            <pre><code>// main.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

import 'providers/websocket_provider.dart';
import 'providers/chat_provider.dart';
import 'providers/emergency_provider.dart';
import 'providers/location_provider.dart';
import 'providers/user_provider.dart';
import 'screens/login_screen.dart';
import 'screens/dashboard_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) =&gt; WebSocketProvider()),
        ChangeNotifierProvider(create: (_) =&gt; UserProvider()),
        ChangeNotifierProvider(create: (_) =&gt; ChatProvider()),
        ChangeNotifierProvider(create: (_) =&gt; EmergencyProvider()),
        ChangeNotifierProvider(create: (_) =&gt; LocationProvider()),
      ],
      child: HPlusApp(),
    ),
  );
}

class HPlusApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'HPlus Medical System',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: SplashScreen(),
      routes: {
        '/login': (context) =&gt; LoginScreen(),
        '/dashboard': (context) =&gt; DashboardScreen(),
      },
    );
  }
}

class SplashScreen extends StatefulWidget {
  @override
  _SplashScreenState createState() =&gt; _SplashScreenState();
}

class _SplashScreenState extends State&lt;SplashScreen&gt; {
  @override
  void initState() {
    super.initState();
    _checkAuthStatus();
  }

  Future&lt;void&gt; _checkAuthStatus() async {
    final prefs = await SharedPreferences.getInstance();
    final userId = prefs.getString('user_id');
    
    await Future.delayed(Duration(seconds: 2)); // Splash delay
    
    if (userId != null) {
      // Auto-login if credentials exist
      final userProvider = context.read&lt;UserProvider&gt;();
      final success = await userProvider.autoLogin();
      
      if (success) {
        Navigator.pushReplacementNamed(context, '/dashboard');
      } else {
        Navigator.pushReplacementNamed(context, '/login');
      }
    } else {
      Navigator.pushReplacementNamed(context, '/login');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.blue[600],
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.local_hospital,
              size: 100,
              color: Colors.white,
            ),
            SizedBox(height: 20),
            Text(
              'HPlus Medical System',
              style: TextStyle(
                fontSize: 28,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
            SizedBox(height: 40),
            CircularProgressIndicator(
              valueColor: AlwaysStoppedAnimation&lt;Color&gt;(Colors.white),
            ),
          ],
        ),
      ),
    );
  }
}</code></pre>

            <h2>Complete Dashboard Implementation</h2>
            <pre><code>// screens/dashboard_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

class DashboardScreen extends StatefulWidget {
  @override
  _DashboardScreenState createState() =&gt; _DashboardScreenState();
}

class _DashboardScreenState extends State&lt;DashboardScreen&gt; {
  int _currentIndex = 0;
  
  final List&lt;Widget&gt; _screens = [
    DashboardHomeScreen(),
    ChatListScreen(),
    EmergencyScreen(),
    LocationScreen(),
  ];

  @override
  void initState() {
    super.initState();
    _initializeServices();
  }

  Future&lt;void&gt; _initializeServices() async {
    final webSocketProvider = context.read&lt;WebSocketProvider&gt;();
    final chatProvider = context.read&lt;ChatProvider&gt;();
    final emergencyProvider = context.read&lt;EmergencyProvider&gt;();
    final locationProvider = context.read&lt;LocationProvider&gt;();

    // Initialize all providers
    chatProvider.initialize();
    emergencyProvider.initialize();
    locationProvider.initialize();

    // Connect WebSocket
    await webSocketProvider.connectWithUserRole();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('HPlus Medical'),
        backgroundColor: Colors.blue[600],
        actions: [
          // Connection status indicator
          Consumer&lt;WebSocketProvider&gt;(
            builder: (context, provider, child) {
              return Container(
                margin: EdgeInsets.only(right: 16),
                child: Row(
                  children: [
                    Icon(
                      provider.isConnected ? Icons.wifi : Icons.wifi_off,
                      color: provider.isConnected ? Colors.green : Colors.red,
                    ),
                    SizedBox(width: 4),
                    Text(
                      provider.isConnected ? 'Online' : 'Offline',
                      style: TextStyle(fontSize: 12),
                    ),
                  ],
                ),
              );
            },
          ),
          PopupMenuButton(
            itemBuilder: (context) =&gt; [
              PopupMenuItem(
                value: 'profile',
                child: Row(
                  children: [
                    Icon(Icons.person),
                    SizedBox(width: 8),
                    Text('Profile'),
                  ],
                ),
              ),
              PopupMenuItem(
                value: 'settings',
                child: Row(
                  children: [
                    Icon(Icons.settings),
                    SizedBox(width: 8),
                    Text('Settings'),
                  ],
                ),
              ),
              PopupMenuItem(
                value: 'logout',
                child: Row(
                  children: [
                    Icon(Icons.logout),
                    SizedBox(width: 8),
                    Text('Logout'),
                  ],
                ),
              ),
            ],
            onSelected: (value) =&gt; _handleMenuAction(value),
          ),
        ],
      ),
      body: IndexedStack(
        index: _currentIndex,
        children: _screens,
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (index) =&gt; setState(() =&gt; _currentIndex = index),
        type: BottomNavigationBarType.fixed,
        selectedItemColor: Colors.blue[600],
        items: [
          BottomNavigationBarItem(
            icon: Icon(Icons.dashboard),
            label: 'Dashboard',
          ),
          BottomNavigationBarItem(
            icon: _buildChatBadge(),
            label: 'Chat',
          ),
          BottomNavigationBarItem(
            icon: _buildEmergencyBadge(),
            label: 'Emergency',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.location_on),
            label: 'Location',
          ),
        ],
      ),
    );
  }

  Widget _buildChatBadge() {
    return Consumer&lt;ChatProvider&gt;(
      builder: (context, chatProvider, child) {
        final unreadCount = chatProvider.getUnreadMessageCount();
        
        return Stack(
          children: [
            Icon(Icons.chat),
            if (unreadCount &gt; 0)
              Positioned(
                right: 0,
                top: 0,
                child: Container(
                  padding: EdgeInsets.all(2),
                  decoration: BoxDecoration(
                    color: Colors.red,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  constraints: BoxConstraints(
                    minWidth: 16,
                    minHeight: 16,
                  ),
                  child: Text(
                    '$unreadCount',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 10,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  Widget _buildEmergencyBadge() {
    return Consumer&lt;EmergencyProvider&gt;(
      builder: (context, emergencyProvider, child) {
        final activeAlerts = emergencyProvider.activeAlerts.length;
        
        return Stack(
          children: [
            Icon(Icons.emergency),
            if (activeAlerts &gt; 0)
              Positioned(
                right: 0,
                top: 0,
                child: Container(
                  padding: EdgeInsets.all(2),
                  decoration: BoxDecoration(
                    color: Colors.red,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  constraints: BoxConstraints(
                    minWidth: 16,
                    minHeight: 16,
                  ),
                  child: Text(
                    '$activeAlerts',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 10,
                    ),
                    textAlign: TextAlign.center,
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  void _handleMenuAction(String action) {
    switch (action) {
      case 'profile':
        // Navigate to profile screen
        break;
      case 'settings':
        // Navigate to settings screen
        break;
      case 'logout':
        _showLogoutDialog();
        break;
    }
  }

  void _showLogoutDialog() {
    showDialog(
      context: context,
      builder: (context) =&gt; AlertDialog(
        title: Text('Logout'),
        content: Text('Are you sure you want to logout?'),
        actions: [
          TextButton(
            onPressed: () =&gt; Navigator.pop(context),
            child: Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              // Disconnect WebSocket
              await context.read&lt;WebSocketProvider&gt;().disconnect();
              
              // Clear user data
              await context.read&lt;UserProvider&gt;().logout();
              
              // Navigate to login
              Navigator.pushNamedAndRemoveUntil(
                context,
                '/login',
                (route) =&gt; false,
              );
            },
            child: Text('Logout'),
          ),
        ],
      ),
    );
  }
}</code></pre>

            <h2>User Provider Implementation</h2>
            <pre><code>// providers/user_provider.dart
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/auth_service.dart';
import '../models/user.dart';

class UserProvider extends ChangeNotifier {
  User? _currentUser;
  bool _isLoading = false;

  User? get currentUser =&gt; _currentUser;
  bool get isLoading =&gt; _isLoading;
  bool get isLoggedIn =&gt; _currentUser != null;

  Future&lt;bool&gt; login(String email, String password) async {
    _isLoading = true;
    notifyListeners();

    try {
      final result = await AuthService.authenticateUser(email, password);
      
      if (result['success']) {
        _currentUser = User.fromJson(result['user']);
        _isLoading = false;
        notifyListeners();
        return true;
      } else {
        _isLoading = false;
        notifyListeners();
        return false;
      }
    } catch (e) {
      _isLoading = false;
      notifyListeners();
      return false;
    }
  }

  Future&lt;bool&gt; autoLogin() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final userId = prefs.getString('user_id');
      final userRole = prefs.getString('user_role');
      final userName = prefs.getString('user_name');
      final userEmail = prefs.getString('user_email');
      final hospitalId = prefs.getString('hospital_id');

      if (userId != null && userRole != null) {
        _currentUser = User(
          id: userId,
          name: userName ?? '',
          email: userEmail ?? '',
          role: userRole,
          hospitalId: hospitalId,
        );
        notifyListeners();
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }

  Future&lt;void&gt; logout() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.clear();
    _currentUser = null;
    notifyListeners();
  }

  Future&lt;void&gt; updateUserStatus(String status, {String? customMessage}) async {
    if (_currentUser != null) {
      // Update user status through WebSocket
      // Implementation depends on your WebSocket service
    }
  }
}</code></pre>
        </div>        <!-- Section 10: Error Handling & Best Practices -->
        <div class="section page-break" id="error-handling">
            <h1>10. ‚ö†Ô∏è Error Handling & Best Practices</h1>
            
            <h2>Comprehensive Error Handling</h2>
            <pre><code>class WebSocketErrorHandler {
  static void handleWebSocketError(String error, BuildContext context) {
    print('WebSocket Error: $error');
    
    if (error.contains('Authentication required')) {
      _handleAuthError(context);
    } else if (error.contains('Hospital ID is required')) {
      _handleHospitalIdError(context);
    } else if (error.contains('Connection timeout')) {
      _handleConnectionTimeout(context);
    } else if (error.contains('Unable to reconnect')) {
      _handleReconnectionFailure(context);
    } else {
      _handleGenericError(error, context);
    }
  }

  static void _handleAuthError(BuildContext context) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) =&gt; AlertDialog(
        title: Row(
          children: [
            Icon(Icons.error, color: Colors.red),
            SizedBox(width: 8),
            Text('Authentication Error'),
          ],
        ),
        content: Text(
          'Your session has expired. Please log in again to continue.',
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              Navigator.pushNamedAndRemoveUntil(
                context,
                '/login',
                (route) =&gt; false,
              );
            },
            child: Text('Login Again'),
          ),
        ],
      ),
    );
  }

  static void _handleConnectionTimeout(BuildContext context) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            Icon(Icons.wifi_off, color: Colors.white),
            SizedBox(width: 8),
            Text('Connection timeout. Attempting to reconnect...'),
          ],
        ),
        backgroundColor: Colors.orange,
        duration: Duration(seconds: 3),
        action: SnackBarAction(
          label: 'Retry',
          textColor: Colors.white,
          onPressed: () {
            context.read&lt;WebSocketProvider&gt;().reconnect();
          },
        ),
      ),
    );
  }

  static void _handleReconnectionFailure(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isDismissible: false,
      builder: (context) =&gt; Container(
        padding: EdgeInsets.all(20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.cloud_off, size: 48, color: Colors.red),
            SizedBox(height: 16),
            Text(
              'Connection Failed',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 8),
            Text(
              'Unable to connect to the server. Please check your internet connection and try again.',
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 20),
            Row(
              children: [
                Expanded(
                  child: ElevatedButton(
                    onPressed: () {
                      Navigator.pop(context);
                      context.read&lt;WebSocketProvider&gt;().reconnect();
                    },
                    child: Text('Retry Connection'),
                  ),
                ),
                SizedBox(width: 16),
                Expanded(
                  child: TextButton(
                    onPressed: () {
                      Navigator.pop(context);
                      // Continue in offline mode
                    },
                    child: Text('Work Offline'),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}</code></pre>

            <h2>Performance Best Practices</h2>
            <div class="info-box">
                <strong>‚ö° Performance Optimization Tips:</strong>
                <ul>
                    <li><strong>Message Throttling:</strong> Limit message sending rate to prevent spam</li>
                    <li><strong>Memory Management:</strong> Clear old messages and limit chat history</li>
                    <li><strong>Efficient Rebuilds:</strong> Use Consumer widgets strategically</li>
                    <li><strong>Background Tasks:</strong> Handle WebSocket in background threads</li>
                    <li><strong>State Persistence:</strong> Save critical data locally</li>
                </ul>
            </div>

            <h2>Message Rate Limiting</h2>
            <pre><code>class MessageRateLimiter {
  static const int maxMessagesPerMinute = 30;
  static const Duration timeWindow = Duration(minutes: 1);
  
  final List&lt;DateTime&gt; _messageTimes = [];

  bool canSendMessage() {
    final now = DateTime.now();
    
    // Remove old messages outside time window
    _messageTimes.removeWhere(
      (time) =&gt; now.difference(time) &gt; timeWindow,
    );
    
    if (_messageTimes.length &gt;= maxMessagesPerMinute) {
      return false;
    }
    
    _messageTimes.add(now);
    return true;
  }

  Duration getWaitTime() {
    if (_messageTimes.isEmpty) return Duration.zero;
    
    final oldestMessage = _messageTimes.first;
    final timeSinceOldest = DateTime.now().difference(oldestMessage);
    
    if (timeSinceOldest &gt;= timeWindow) {
      return Duration.zero;
    }
    
    return timeWindow - timeSinceOldest;
  }
}</code></pre>

            <h2>Memory Management</h2>
            <pre><code>class ChatProvider extends ChangeNotifier {
  static const int maxMessagesPerConversation = 100;
  static const int maxTotalMessages = 500;
  
  void _cleanupOldMessages() {
    // Remove old messages when limit is exceeded
    if (_messages.length &gt; maxTotalMessages) {
      final messagesToRemove = _messages.length - maxTotalMessages;
      _messages.removeRange(0, messagesToRemove);
    }
    
    // Clean up conversations
    for (final conversationKey in _conversations.keys) {
      final messages = _conversations[conversationKey]!;
      if (messages.length &gt; maxMessagesPerConversation) {
        final messagesToRemove = messages.length - maxMessagesPerConversation;
        messages.removeRange(0, messagesToRemove);
      }
    }
  }

  @override
  void dispose() {
    _webSocketService.messageStream.listen((data) {}).cancel();
    super.dispose();
  }
}</code></pre>

            <h2>Offline Mode Support</h2>
            <pre><code>class OfflineMessageQueue {
  static const String _storageKey = 'offline_messages';
  final List&lt;Map&lt;String, dynamic&gt;&gt; _queuedMessages = [];

  Future&lt;void&gt; queueMessage(Map&lt;String, dynamic&gt; message) async {
    message['queuedAt'] = DateTime.now().toIso8601String();
    _queuedMessages.add(message);
    await _saveToStorage();
  }

  Future&lt;void&gt; sendQueuedMessages(WebSocketService webSocketService) async {
    if (_queuedMessages.isEmpty) return;

    final messagesToSend = List&lt;Map&lt;String, dynamic&gt;&gt;.from(_queuedMessages);
    _queuedMessages.clear();

    for (final message in messagesToSend) {
      try {
        await webSocketService.sendMessage(message);
        await Future.delayed(Duration(milliseconds: 100)); // Throttle
      } catch (e) {
        // Re-queue failed messages
        _queuedMessages.add(message);
      }
    }

    await _saveToStorage();
  }

  Future&lt;void&gt; _saveToStorage() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = json.encode(_queuedMessages);
    await prefs.setString(_storageKey, jsonString);
  }

  Future&lt;void&gt; loadFromStorage() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_storageKey);
    
    if (jsonString != null) {
      final List&lt;dynamic&gt; decoded = json.decode(jsonString);
      _queuedMessages.clear();
      _queuedMessages.addAll(decoded.cast&lt;Map&lt;String, dynamic&gt;&gt;());
    }
  }
}</code></pre>

            <h2>Security Best Practices</h2>
            <div class="warning-box">
                <strong>üîí Security Guidelines:</strong>
                <ul>
                    <li><strong>Token Security:</strong> Store JWT tokens securely using flutter_secure_storage</li>
                    <li><strong>Input Validation:</strong> Validate all user inputs before sending</li>
                    <li><strong>HTTPS/WSS:</strong> Always use secure connections in production</li>
                    <li><strong>Role Verification:</strong> Verify user permissions on both client and server</li>
                    <li><strong>Message Encryption:</strong> Consider encrypting sensitive messages</li>
                </ul>
            </div>

            <h2>Secure Token Storage</h2>
            <pre><code>import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class SecureStorageService {
  static const FlutterSecureStorage _storage = FlutterSecureStorage(
    aOptions: AndroidOptions(
      encryptedSharedPreferences: true,
    ),
    iOptions: IOSOptions(
      accessibility: IOSAccessibility.first_unlock_this_device,
    ),
  );

  static Future&lt;void&gt; storeToken(String token) async {
    await _storage.write(key: 'auth_token', value: token);
  }

  static Future&lt;String?&gt; getToken() async {
    return await _storage.read(key: 'auth_token');
  }

  static Future&lt;void&gt; deleteToken() async {
    await _storage.delete(key: 'auth_token');
  }

  static Future&lt;void&gt; storeUserCredentials(Map&lt;String, String&gt; credentials) async {
    for (final entry in credentials.entries) {
      await _storage.write(key: entry.key, value: entry.value);
    }
  }

  static Future&lt;void&gt; clearAllSecureData() async {
    await _storage.deleteAll();
  }
}</code></pre>
        </div>        <!-- Section 11: Testing & Debugging -->
        <div class="section page-break" id="testing">
            <h1>11. üß™ Testing & Debugging</h1>
            
            <h2>WebSocket Connection Testing</h2>
            <pre><code>// test/websocket_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:web_socket_channel/web_socket_channel.dart';

import '../lib/services/websocket_service.dart';

class MockWebSocketChannel extends Mock implements WebSocketChannel {}

void main() {
  group('WebSocket Service Tests', () {
    late WebSocketService webSocketService;
    late MockWebSocketChannel mockChannel;

    setUp(() {
      webSocketService = WebSocketService();
      mockChannel = MockWebSocketChannel();
    });

    test('should connect successfully with valid parameters', () async {
      // Arrange
      const testUrl = 'ws://localhost:5000?userId=test123&role=doctor';
      
      // Act
      await webSocketService.connect(testUrl);
      
      // Assert
      expect(webSocketService.isConnected, isTrue);
    });

    test('should handle connection errors gracefully', () async {
      // Arrange
      const invalidUrl = 'ws://invalid-url:9999';
      
      // Act & Assert
      expect(
        () =&gt; webSocketService.connect(invalidUrl),
        throwsException,
      );
    });

    test('should send messages in correct format', () async {
      // Arrange
      const testMessage = {
        'type': 'send_message',
        'payload': {
          'recipientId': 'user123',
          'content': 'Test message',
          'messageType': 'text',
        },
      };
      
      // Act
      webSocketService.sendMessage(testMessage);
      
      // Assert
      verify(mockChannel.sink.add(any)).called(1);
    });

    test('should reconnect after connection loss', () async {
      // Arrange
      await webSocketService.connect('ws://localhost:5000');
      
      // Simulate connection loss
      webSocketService.handleConnectionError('Connection lost');
      
      // Act
      await Future.delayed(Duration(seconds: 2));
      
      // Assert
      expect(webSocketService.isConnected, isTrue);
    });
  });
}</code></pre>

            <h2>Provider Testing</h2>
            <pre><code>// test/chat_provider_test.dart
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';

import '../lib/providers/chat_provider.dart';
import '../lib/models/chat_message.dart';

void main() {
  group('Chat Provider Tests', () {
    late ChatProvider chatProvider;

    setUp(() {
      chatProvider = ChatProvider();
    });

    test('should add new message to conversation', () {
      // Arrange
      final testMessage = ChatMessage(
        id: 'msg123',
        senderId: 'user1',
        senderName: 'John Doe',
        senderRole: 'doctor',
        recipientId: 'user2',
        content: 'Test message',
        type: 'text',
        timestamp: DateTime.now(),
      );

      // Act
      chatProvider.addMessage(testMessage);

      // Assert
      expect(chatProvider.messages.length, equals(1));
      expect(chatProvider.messages.first.content, equals('Test message'));
    });

    test('should organize messages by conversation', () {
      // Arrange
      final message1 = ChatMessage(
        id: 'msg1',
        senderId: 'user1',
        senderName: 'John',
        senderRole: 'doctor',
        recipientId: 'user2',
        content: 'Hello',
        type: 'text',
        timestamp: DateTime.now(),
      );

      final message2 = ChatMessage(
        id: 'msg2',
        senderId: 'user2',
        senderName: 'Jane',
        senderRole: 'nurse',
        recipientId: 'user1',
        content: 'Hi there',
        type: 'text',
        timestamp: DateTime.now(),
      );

      // Act
      chatProvider.addMessage(message1);
      chatProvider.addMessage(message2);

      // Assert
      final conversation = chatProvider.getConversation('user1', 'user2');
      expect(conversation.length, equals(2));
    });

    test('should mark message as read', () {
      // Arrange
      final testMessage = ChatMessage(
        id: 'msg123',
        senderId: 'user1',
        senderName: 'John',
        senderRole: 'doctor',
        recipientId: 'user2',
        content: 'Test',
        type: 'text',
        timestamp: DateTime.now(),
        isRead: false,
      );

      chatProvider.addMessage(testMessage);

      // Act
      chatProvider.markMessageAsRead('msg123');

      // Assert
      final updatedMessage = chatProvider.messages.firstWhere(
        (m) =&gt; m.id == 'msg123',
      );
      expect(updatedMessage.isRead, isTrue);
    });
  });
}</code></pre>

            <h2>Integration Testing</h2>
            <pre><code>// integration_test/app_test.dart
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';

import 'package:hplus_app/main.dart' as app;

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  group('HPlus App Integration Tests', () {
    testWidgets('complete login and chat flow', (WidgetTester tester) async {
      // Start the app
      app.main();
      await tester.pumpAndSettle();

      // Test login flow
      await tester.enterText(
        find.byKey(Key('email_field')),
        'doctor@example.com',
      );
      await tester.enterText(
        find.byKey(Key('password_field')),
        'password123',
      );
      await tester.tap(find.byKey(Key('login_button')));
      await tester.pumpAndSettle(Duration(seconds: 3));

      // Verify dashboard appears
      expect(find.text('HPlus Medical'), findsOneWidget);
      expect(find.byIcon(Icons.dashboard), findsOneWidget);

      // Test WebSocket connection
      await tester.pump(Duration(seconds: 2));
      expect(find.text('Online'), findsOneWidget);

      // Navigate to chat
      await tester.tap(find.byIcon(Icons.chat));
      await tester.pumpAndSettle();

      // Test sending a message
      await tester.enterText(
        find.byKey(Key('message_input')),
        'Test integration message',
      );
      await tester.tap(find.byIcon(Icons.send));
      await tester.pumpAndSettle();

      // Verify message appears
      expect(find.text('Test integration message'), findsOneWidget);
    });

    testWidgets('emergency alert flow', (WidgetTester tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Login first
      await _performLogin(tester);

      // Navigate to emergency tab
      await tester.tap(find.byIcon(Icons.emergency));
      await tester.pumpAndSettle();

      // Create emergency alert
      await tester.tap(find.byKey(Key('create_emergency_button')));
      await tester.pumpAndSettle();

      await tester.tap(find.text('Cardiac'));
      await tester.tap(find.text('Critical'));
      await tester.enterText(
        find.byKey(Key('emergency_description')),
        'Patient experiencing chest pain',
      );
      
      await tester.tap(find.byKey(Key('submit_emergency')));
      await tester.pumpAndSettle();

      // Verify alert was created
      expect(find.text('Emergency alert sent'), findsOneWidget);
    });
  });
}

Future&lt;void&gt; _performLogin(WidgetTester tester) async {
  await tester.enterText(
    find.byKey(Key('email_field')),
    'doctor@example.com',
  );
  await tester.enterText(
    find.byKey(Key('password_field')),
    'password123',
  );
  await tester.tap(find.byKey(Key('login_button')));
  await tester.pumpAndSettle(Duration(seconds: 3));
}</code></pre>

            <h2>Debugging Tools</h2>
            <div class="info-box">
                <strong>üîß Debugging Tools & Techniques:</strong>
                <ul>
                    <li><strong>WebSocket Inspector:</strong> Use browser dev tools to monitor WebSocket traffic</li>
                    <li><strong>Flutter Inspector:</strong> Debug widget tree and state changes</li>
                    <li><strong>Network Monitoring:</strong> Track API calls and responses</li>
                    <li><strong>Console Logging:</strong> Add strategic print statements</li>
                    <li><strong>Error Tracking:</strong> Implement crash reporting with Firebase Crashlytics</li>
                </ul>
            </div>

            <h2>Debug Logging Service</h2>
            <pre><code>class DebugLogger {
  static const bool _isDebugMode = kDebugMode;
  
  static void logWebSocketEvent(String event, Map&lt;String, dynamic&gt;? data) {
    if (_isDebugMode) {
      print('üîå WebSocket Event: $event');
      if (data != null) {
        print('üìÑ Data: ${json.encode(data)}');
      }
      print('‚è∞ Time: ${DateTime.now().toIso8601String()}');
      print('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    }
  }

  static void logError(String context, dynamic error, StackTrace? stackTrace) {
    if (_isDebugMode) {
      print('‚ùå Error in $context: $error');
      if (stackTrace != null) {
        print('üìç Stack Trace:');
        print(stackTrace.toString());
      }
      print('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    }
  }

  static void logUserAction(String action, Map&lt;String, dynamic&gt;? details) {
    if (_isDebugMode) {
      print('üë§ User Action: $action');
      if (details != null) {
        print('üìã Details: ${json.encode(details)}');
      }
      print('‚è∞ Time: ${DateTime.now().toIso8601String()}');
      print('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    }
  }
}</code></pre>

            <h2>Performance Monitoring</h2>
            <pre><code>class PerformanceMonitor {
  static final Map&lt;String, DateTime&gt; _startTimes = {};
  
  static void startTiming(String operation) {
    _startTimes[operation] = DateTime.now();
  }
  
  static void endTiming(String operation) {
    final startTime = _startTimes[operation];
    if (startTime != null) {
      final duration = DateTime.now().difference(startTime);
      DebugLogger.logUserAction(
        'Performance: $operation completed',
        {'duration_ms': duration.inMilliseconds},
      );
      _startTimes.remove(operation);
    }
  }
  
  static void measureWidgetBuild(String widgetName, VoidCallback buildFunction) {
    startTiming('Build $widgetName');
    buildFunction();
    endTiming('Build $widgetName');
  }
}</code></pre>
        </div>        <!-- Section 12: Appendix & Quick Reference -->
        <div class="section page-break" id="appendix">
            <h1>12. üìö Appendix & Quick Reference</h1>
            
            <h2>Dependencies Reference</h2>
            <div class="info-box">
                <strong>üì¶ Required Flutter Dependencies:</strong>
                <p>Add these to your <code>pubspec.yaml</code> file:</p>
            </div>
            
            <pre><code>dependencies:
  flutter:
    sdk: flutter
  
  # WebSocket & Networking
  web_socket_channel: ^2.4.0
  http: ^1.1.0
  
  # State Management
  provider: ^6.1.1
  
  # Storage
  shared_preferences: ^2.2.2
  flutter_secure_storage: ^9.0.0
  
  # Location Services
  geolocator: ^10.1.0
  permission_handler: ^11.0.1
  
  # UI & Navigation
  flutter_local_notifications: ^16.1.0
  
  # Utilities
  connectivity_plus: ^5.0.1

dev_dependencies:
  flutter_test:
    sdk: flutter
  integration_test:
    sdk: flutter
  mockito: ^5.4.2
  build_runner: ^2.4.7</code></pre>

            <h2>Environment Configuration</h2>
            <h3>Development Environment</h3>
            <pre><code>// lib/config/env_config.dart
class EnvConfig {
  static const String environment = String.fromEnvironment(
    'ENVIRONMENT',
    defaultValue: 'development',
  );
  
  static const String wsBaseUrl = String.fromEnvironment(
    'WS_BASE_URL',
    defaultValue: 'ws://localhost:5000',
  );
  
  static const String apiBaseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'http://localhost:3000',
  );
  
  static bool get isDevelopment =&gt; environment == 'development';
  static bool get isProduction =&gt; environment == 'production';
  
  static String get webSocketUrl {
    switch (environment) {
      case 'production':
        return 'wss://api.hplus-medical.com/ws';
      case 'staging':
        return 'wss://staging-api.hplus-medical.com/ws';
      default:
        return wsBaseUrl;
    }
  }
}</code></pre>

            <h3>Production Build Configuration</h3>
            <pre><code># Build commands for different environments

# Development
flutter run --dart-define=ENVIRONMENT=development

# Staging
flutter build apk --dart-define=ENVIRONMENT=staging --dart-define=WS_BASE_URL=wss://staging-api.hplus-medical.com/ws

# Production
flutter build apk --dart-define=ENVIRONMENT=production --dart-define=WS_BASE_URL=wss://api.hplus-medical.com/ws</code></pre>

            <h2>Troubleshooting Guide</h2>
            <div class="warning-box">
                <strong>üîç Common Issues & Solutions:</strong>
                
                <h4>1. WebSocket Connection Fails</h4>
                <ul>
                    <li><strong>Check URL:</strong> Ensure WebSocket URL is correct and accessible</li>
                    <li><strong>Network Permissions:</strong> Add INTERNET permission to AndroidManifest.xml</li>
                    <li><strong>Firewall:</strong> Check if firewall is blocking WebSocket connections</li>
                    <li><strong>Server Status:</strong> Verify the WebSocket server is running</li>
                </ul>

                <h4>2. Authentication Errors</h4>
                <ul>
                    <li><strong>Token Expiry:</strong> Implement token refresh mechanism</li>
                    <li><strong>Role Validation:</strong> Ensure user role is correctly set</li>
                    <li><strong>Hospital ID:</strong> Verify hospital staff have hospitalId parameter</li>
                </ul>

                <h4>3. Location Services Not Working</h4>
                <ul>
                    <li><strong>Permissions:</strong> Request location permissions properly</li>
                    <li><strong>GPS Settings:</strong> Check if location services are enabled</li>
                    <li><strong>Background Location:</strong> Handle background location permissions</li>
                </ul>

                <h4>4. Messages Not Delivered</h4>
                <ul>
                    <li><strong>Connection Status:</strong> Check WebSocket connection status</li>
                    <li><strong>Message Format:</strong> Validate message structure</li>
                    <li><strong>Rate Limiting:</strong> Check if rate limits are exceeded</li>
                    <li><strong>Recipient ID:</strong> Verify recipient exists and is online</li>
                </ul>
            </div>

            <h2>Code Templates</h2>
            <h3>Quick WebSocket Setup</h3>
            <pre><code>// Quick setup template for new Flutter project
void main() {
  runApp(
    MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) =&gt; WebSocketProvider()),
        ChangeNotifierProvider(create: (_) =&gt; ChatProvider()),
        ChangeNotifierProvider(create: (_) =&gt; EmergencyProvider()),
      ],
      child: MyApp(),
    ),
  );
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        body: Consumer&lt;WebSocketProvider&gt;(
          builder: (context, wsProvider, child) {
            if (!wsProvider.isConnected) {
              return ElevatedButton(
                onPressed: () async {
                  await wsProvider.connect(
                    'ws://localhost:5000?userId=user123&role=doctor'
                  );
                },
                child: Text('Connect to WebSocket'),
              );
            }
            return Text('Connected to WebSocket!');
          },
        ),
      ),
    );
  }
}</code></pre>

            <h3>Emergency Alert Template</h3>
            <pre><code>// Quick emergency alert setup
void sendEmergencyAlert() {
  final emergencyData = {
    'type': 'create_emergency',
    'payload': {
      'alertType': 'cardiac',
      'severity': 'critical',
      'description': 'Patient experiencing chest pain',
      'location': {
        'latitude': 40.7128,
        'longitude': -74.0060,
      },
    },
  };
  
  context.read&lt;WebSocketProvider&gt;().sendMessage(emergencyData);
}</code></pre>

            <h2>API Reference Summary</h2>
            <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                <thead>
                    <tr style="background-color: #f8f9fa;">
                        <th style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">Message Type</th>
                        <th style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">Direction</th>
                        <th style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;"><code>send_message</code></td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Outgoing</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Send chat message to another user</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;"><code>chat_message</code></td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Incoming</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Receive chat message from another user</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;"><code>create_emergency</code></td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Outgoing</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Create new emergency alert</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;"><code>emergency_alert</code></td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Incoming</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Receive emergency alert notification</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;"><code>location_update</code></td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Both</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Share/receive location updates</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;"><code>accept_emergency</code></td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Outgoing</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Accept emergency alert assignment</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;"><code>mark_message_read</code></td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Outgoing</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Mark message as read</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;"><code>user_status_change</code></td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Incoming</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Receive user status updates</td>
                    </tr>
                </tbody>
            </table>

            <h2>Support & Resources</h2>
            <div class="info-box">
                <strong>üîó Additional Resources:</strong>
                <ul>
                    <li><strong>Flutter WebSocket Documentation:</strong> <a href="https://pub.dev/packages/web_socket_channel">web_socket_channel package</a></li>
                    <li><strong>Provider State Management:</strong> <a href="https://pub.dev/packages/provider">provider package</a></li>
                    <li><strong>Location Services:</strong> <a href="https://pub.dev/packages/geolocator">geolocator package</a></li>
                    <li><strong>Local Notifications:</strong> <a href="https://pub.dev/packages/flutter_local_notifications">flutter_local_notifications</a></li>
                    <li><strong>Flutter Testing:</strong> <a href="https://flutter.dev/docs/testing">Official Flutter Testing Guide</a></li>
                </ul>
            </div>

            <div class="warning-box">
                <strong>üìû Getting Help:</strong>
                <p>If you encounter issues or need assistance:</p>
                <ul>
                    <li>Check the troubleshooting guide above</li>
                    <li>Review the WebSocket server logs</li>
                    <li>Test with the provided code examples</li>
                    <li>Verify all dependencies are properly installed</li>
                    <li>Contact the development team for advanced support</li>
                </ul>
            </div>

            <h2>Version History</h2>
            <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                <thead>
                    <tr style="background-color: #f8f9fa;">
                        <th style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">Version</th>
                        <th style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">Date</th>
                        <th style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">Changes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">v1.0.0</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">2024-01-15</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Initial release with complete WebSocket integration guide</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">v1.1.0</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">2024-01-20</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Added emergency system and location sharing</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">v1.2.0</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">2024-01-25</td>
                        <td style="border: 1px solid #dee2e6; padding: 8px;">Enhanced error handling and testing examples</td>
                    </tr>
                </tbody>
            </table>

            <div style="text-align: center; margin-top: 40px; padding: 20px; background-color: #f8f9fa; border-radius: 8px;">
                <h3 style="color: #2d3748; margin-bottom: 10px;">End of Documentation</h3>
                <p style="color: #4a5568; margin-bottom: 0;">Thank you for using the HPlus Medical System WebSocket Integration Guide!</p>
                <p style="color: #718096; font-size: 14px;">Generated on January 15, 2024 ‚Ä¢ Version 1.2.0</p>
            </div>
        </div>

        <!-- Navigation -->
        <div class="nav-buttons">
            <button class="nav-btn" onclick="window.print()">üñ®Ô∏è Print PDF</button>
            <button class="nav-btn" onclick="window.scrollTo(0,0)">‚¨ÜÔ∏è Top</button>
        </div>
    </div>

    <script>
        // Add interactive functionality
        document.addEventListener('DOMContentLoaded', function() {
            // Add smooth scrolling for anchor links
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    e.preventDefault();
                    const target = document.querySelector(this.getAttribute('href'));
                    if (target) {
                        target.scrollIntoView({
                            behavior: 'smooth',
                            block: 'start'
                        });
                    }
                });
            });

            // Add copy code functionality
            document.querySelectorAll('pre code').forEach(block => {
                const button = document.createElement('button');
                button.className = 'copy-btn';
                button.textContent = 'üìã Copy';
                button.style.cssText = `
                    position: absolute;
                    top: 10px;
                    right: 10px;
                    background: #667eea;
                    color: white;
                    border: none;
                    padding: 5px 10px;
                    border-radius: 4px;
                    font-size: 12px;
                    cursor: pointer;
                `;
                
                const container = block.parentElement;
                container.style.position = 'relative';
                container.appendChild(button);
                
                button.addEventListener('click', () => {
                    navigator.clipboard.writeText(block.textContent);
                    button.textContent = '‚úÖ Copied!';
                    setTimeout(() => {
                        button.textContent = 'üìã Copy';
                    }, 2000);
                });
            });
        });
    </script>
</body>
</html>
